#pragma once
#include "abc.h"
#include "math.h"
#include "xtr1common"

#if __ywstd_is_exported or __ywstd_is_imported
#define _CSTD ::
#define __ywstd_cfunc_begin extern "C" {
#define __ywstd_cfunc_end }
#else
#define _CSTD ::__ywstd_cfunc::
#define __ywstd_cfunc_begin extern "C" { namespace __ywstd_cfunc {
#define __ywstd_cfunc_end } }
#endif

__ywstd_export namespace std {

using ::float_t;
using ::double_t;

template<typename T> concept _arithmetic = is_arithmetic_v<T>;
template<typename T, typename... Ts> concept _all_the_same = (is_same_v<T, Ts> && ...);

template<_arithmetic... Ts> using _common_math_t =
  decltype((conditional_t<is_integral_v<Ts>, double, Ts>{} + ...));
}

////////////////////////////////////////////////////////////////////////////////
// fpclassify
__ywstd_cfunc_begin
short __cdecl _dtest(double*);
short __cdecl _fdtest(float*);
short __cdecl _ldtest(long double*);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr int fpclassify(T x) noexcept {
  if constexpr (is_floating_point_v<T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<T, float>) return _CSTD _fdtest(&x);
      else if constexpr (is_same_v<T, double>) return _CSTD _dtest(&x);
      else if constexpr (is_same_v<T, long double>) return _CSTD _ldtest(&x);
    } {
      using UT = conditional_t<sizeof(T) == 4, unsigned, unsigned long long>;
      constexpr UT exp_mask = static_cast<UT>(sizeof(UT) == 4 ? 0x7F800000 : 0x7FF0000000000000);
      const UT u = __builtin_bit_cast(UT, x);
      if (x == T(0)) return FP_ZERO;
      else if (((u & exp_mask) | exp_mask) == 0) return FP_SUBNORMAL;
      else if ((u & exp_mask) == exp_mask) return (u & ~exp_mask) == 0 ? FP_INFINITE : FP_NAN;
      else return FP_NORMAL;
    }
  } else return std::fpclassify(static_cast<double>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// isfinite, isinf, isnan, isnormal
__ywstd_export namespace std {
template<_arithmetic T> constexpr bool isfinite(const T x) noexcept {
  if constexpr (is_floating_point_v<T>) {
    const auto fp = fpclassify(x);
    return fp != FP_INFINITE && fp != FP_NAN;
  } else return std::isfinite(static_cast<double>(x));
}
template<_arithmetic T> constexpr bool isinf(const T x) noexcept {
  if constexpr (is_floating_point_v<T>) return fpclassify(x) == FP_INFINITE;
  else return std::isinf(static_cast<double>(x));
}
template<_arithmetic T> constexpr bool isnan(const T x) noexcept {
  if constexpr (is_floating_point_v<T>) return fpclassify(x) == FP_NAN;
  else return std::isnan(static_cast<double>(x));
}
template<_arithmetic T> constexpr bool isnormal(const T x) noexcept {
  if constexpr (is_floating_point_v<T>) return fpclassify(x) == FP_NORMAL;
  else return std::isnormal(static_cast<double>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// signbit
__ywstd_cfunc_begin
int __cdecl _dsign(double);
int __cdecl _fdsign(float);
int __cdecl _ldsign(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr bool signbit(const T x) noexcept {
  if constexpr (is_floating_point_v<T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<T, float>) return _CSTD _fdsign(x);
      else if constexpr (is_same_v<T, double>) return _CSTD _dsign(x);
      else if constexpr (is_same_v<T, long double>) return _CSTD _ldsign(x);
    } else return x < T(0);
  } else return std::signbit(static_cast<double>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// isgreater, isgreaterequal, isless, islessequal, islessgreater, isunordered
__ywstd_cfunc_begin
int __cdecl _dpcomp(double, double);
int __cdecl _fdpcomp(float, float);
int __cdecl _ldpcomp(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> constexpr bool isgreater(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) __ywstd_cwrapr(bool(_CSTD _fdpcomp(x, y) & 4));
      else if constexpr (is_same_v<common, double>) __ywstd_cwrapr(bool(_CSTD _dpcomp(x, y) & 4));
      else if constexpr (is_same_v<common, long double>) __ywstd_cwrapr(bool(_CSTD _ldpcomp(x, y) & 4));
    } else return x > y;
  } else return std::isgreater(static_cast<double>(x), static_cast<double>(y));
}
template<_arithmetic T, _arithmetic U> constexpr bool isgreaterequal(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) __ywstd_cwrapr(bool(_CSTD _fdpcomp(x, y) & 6));
      else if constexpr (is_same_v<common, double>) __ywstd_cwrapr(bool(_CSTD _dpcomp(x, y) & 6));
      else if constexpr (is_same_v<common, long double>) __ywstd_cwrapr(bool(_CSTD _ldpcomp(x, y) & 6));
    } else return x >= y;
  } else return std::isgreaterequal(static_cast<double>(x), static_cast<double>(y));
}
template<_arithmetic T, _arithmetic U> constexpr bool isless(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) __ywstd_cwrapr(bool(_CSTD _fdpcomp(x, y) & 1));
      else if constexpr (is_same_v<common, double>) __ywstd_cwrapr(bool(_CSTD _dpcomp(x, y) & 1));
      else if constexpr (is_same_v<common, long double>) __ywstd_cwrapr(bool(_CSTD _ldpcomp(x, y) & 1));
    } else return x < y;
  } else return std::isless(static_cast<double>(x), static_cast<double>(y));
}
template<_arithmetic T, _arithmetic U> constexpr bool islessequal(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) __ywstd_cwrapr(bool(_CSTD _fdpcomp(x, y) & 3));
      else if constexpr (is_same_v<common, double>) __ywstd_cwrapr(bool(_CSTD _dpcomp(x, y) & 3));
      else if constexpr (is_same_v<common, long double>) __ywstd_cwrapr(bool(_CSTD _ldpcomp(x, y) & 3));
    } else return x <= y;
  } else return std::islessequal(static_cast<double>(x), static_cast<double>(y));
}
template<_arithmetic T, _arithmetic U> constexpr bool islessgreater(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) __ywstd_cwrapr(bool(_CSTD _fdpcomp(x, y) & 5));
      else if constexpr (is_same_v<common, double>) __ywstd_cwrapr(bool(_CSTD _dpcomp(x, y) & 5));
      else if constexpr (is_same_v<common, long double>) __ywstd_cwrapr(bool(_CSTD _ldpcomp(x, y) & 5));
    } else return x != y;
  } else return std::islessgreater(static_cast<double>(x), static_cast<double>(y));
}
template<_arithmetic T, _arithmetic U> constexpr bool isunordered(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD _fdpcomp(x, y) == 0;
      else if constexpr (is_same_v<common, double>) return _CSTD _dpcomp(x, y) == 0;
      else if constexpr (is_same_v<common, long double>) return _CSTD _ldpcomp(x, y) == 0;
    } else return std::isnan(x) || std::isnan(y);
  } else return std::isunordered(static_cast<double>(x), static_cast<double>(y));
}
}
////////////////////////////////////////////////////////////////////////////////
// fabs
__ywstd_cfunc_begin
extern "C" double __cdecl fabs(double);
extern "C" inline float __cdecl fabsf(float x) { return static_cast<float>(_CSTD fabs(x)); }
extern "C" inline long double __cdecl fabsl(long double x) { return _CSTD fabs(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr _common_math_t<T> fabs(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fabsf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD fabs(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD fabsl(x);
    } else return static_cast<common>(x < 0 ? -x : x);
  } else return std::fabs(static_cast<common>(x));
}
constexpr float fabsf(float x) noexcept { return std::fabs(x); }
constexpr long double fabsl(long double x) noexcept { return std::fabs(x); }
}
////////////////////////////////////////////////////////////////////////////////
// ceil
__ywstd_cfunc_begin
extern "C" double __cdecl ceil(double);
extern "C" float __cdecl ceilf(float);
extern "C" inline long double __cdecl ceill(long double x) { return _CSTD ceil(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr _common_math_t<T> ceil(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD ceilf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD ceil(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD ceill(x);
    } else {
      const common i = static_cast<common>(static_cast<long long>(x));
      return static_cast<common>(i == x ? x : (x < 0 ? i : i + 1));
    }
  } else return std::ceil(static_cast<common>(x));
}
constexpr float ceilf(float x) noexcept { return std::ceil(x); }
constexpr long double ceill(long double x) noexcept { return std::ceil(x); }
}
////////////////////////////////////////////////////////////////////////////////
// floor
__ywstd_cfunc_begin
extern "C" double __cdecl floor(double);
extern "C" float __cdecl floorf(float);
extern "C" inline long double __cdecl floorl(long double x) { return _CSTD floor(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr _common_math_t<T> floor(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD floorf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD floor(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD floorl(x);
    } else {
      const common i = static_cast<common>(static_cast<long long>(x));
      return static_cast<common>(i == x ? x : (x < 0 ? i - 1 : i));
    }
  } else return std::floor(static_cast<common>(x));
}
constexpr float floorf(float x) noexcept { return std::floor(x); }
constexpr long double floorl(long double x) noexcept { return std::floor(x); }
}
////////////////////////////////////////////////////////////////////////////////
// trunc
__ywstd_cfunc_begin
extern "C" double __cdecl trunc(double);
extern "C" float __cdecl truncf(float);
extern "C" inline long double __cdecl truncl(long double x) { return _CSTD trunc(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr _common_math_t<T> trunc(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD truncf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD trunc(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD truncl(x);
    } else return static_cast<common>(static_cast<long long>(x));
  } else return std::trunc(static_cast<common>(x));
}
constexpr float truncf(float x) noexcept { return std::trunc(x); }
constexpr long double truncl(long double x) noexcept { return std::trunc(x); }
}
////////////////////////////////////////////////////////////////////////////////
// round
__ywstd_cfunc_begin
extern "C" double __cdecl round(double);
extern "C" float __cdecl roundf(float);
extern "C" long double __cdecl roundl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr _common_math_t<T> round(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD roundf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD round(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD roundl(x);
    } else return static_cast<common>(static_cast<long long>(x + (x < 0 ? -0.5 : 0.5)));
  } else return std::round(static_cast<common>(x));
}
constexpr float roundf(float x) noexcept { return std::round(x); }
constexpr long double roundl(long double x) noexcept { return std::round(x); }
}
////////////////////////////////////////////////////////////////////////////////
// lround
__ywstd_cfunc_begin
extern "C" long __cdecl lround(double);
extern "C" long __cdecl lroundf(float);
extern "C" long __cdecl lroundl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr long lround(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD lroundf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD lround(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD lroundl(x);
    } else return static_cast<long>(std::round(static_cast<double>(x)));
  } else return std::lround(static_cast<double>(x));
}
constexpr long lroundf(float x) noexcept { return std::lround(x); }
constexpr long lroundl(long double x) noexcept { return std::lround(x); }
}
////////////////////////////////////////////////////////////////////////////////
// llround
__ywstd_cfunc_begin
extern "C" long long __cdecl llround(double);
extern "C" long long __cdecl llroundf(float);
extern "C" long long __cdecl llroundl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> constexpr long long llround(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD llroundf(x);
      else if constexpr (is_same_v<common, double>) return _CSTD llround(x);
      else if constexpr (is_same_v<common, long double>) return _CSTD llroundl(x);
    } else return static_cast<long long>(std::round(static_cast<double>(x)));
  } else return std::llround(static_cast<double>(x));
}
constexpr long long llroundf(float x) noexcept { return std::llround(x); }
constexpr long long llroundl(long double x) noexcept { return std::llround(x); }
}
////////////////////////////////////////////////////////////////////////////////
// nearbyint
__ywstd_cfunc_begin
extern "C" double __cdecl nearbyint(double);
extern "C" float __cdecl nearbyintf(float);
extern "C" long double __cdecl nearbyintl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> nearbyint(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD nearbyintf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD nearbyint(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD nearbyintl(x);
  } else return std::nearbyint(static_cast<common>(x));
}
float nearbyintf(float x) noexcept { return std::nearbyint(x); }
long double nearbyintl(long double x) noexcept { return std::nearbyint(x); }
}
////////////////////////////////////////////////////////////////////////////////
// rint
__ywstd_cfunc_begin
extern "C" double __cdecl rint(double);
extern "C" float __cdecl rintf(float);
extern "C" long double __cdecl rintl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> rint(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD rintf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD rint(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD rintl(x);
  } else return std::rint(static_cast<common>(x));
}
float rintf(float x) noexcept { return std::rint(x); }
long double rintl(long double x) noexcept { return std::rint(x); }
}
////////////////////////////////////////////////////////////////////////////////
// lrint
__ywstd_cfunc_begin
extern "C" long __cdecl lrint(double);
extern "C" long __cdecl lrintf(float);
extern "C" long __cdecl lrintl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> long lrint(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD lrintf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD lrint(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD lrintl(x);
  } else return std::lrint(static_cast<common>(x));
}
long lrintf(float x) noexcept { return std::lrint(x); }
long lrintl(long double x) noexcept { return std::lrint(x); }
}
////////////////////////////////////////////////////////////////////////////////
// llrint
__ywstd_cfunc_begin
extern "C" long long __cdecl llrint(double);
extern "C" long long __cdecl llrintf(float);
extern "C" long long __cdecl llrintl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> long long llrint(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD llrintf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD llrint(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD llrintl(x);
  } else return std::llrint(static_cast<common>(x));
}
long long llrintf(float x) noexcept { return std::llrint(x); }
long long llrintl(long double x) noexcept { return std::llrint(x); }
}
////////////////////////////////////////////////////////////////////////////////
// fmod
__ywstd_cfunc_begin
extern "C" double __cdecl fmod(double, double);
extern "C" float __cdecl fmodf(float, float);
extern "C" inline long double __cdecl fmodl(long double x, long double y)
{ return _CSTD fmod(static_cast<double>(x), static_cast<double>(y)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> [[nodiscard]]
constexpr _common_math_t<T, U> fmod(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fmodf(x, y);
      else if constexpr (is_same_v<common, double>) return _CSTD fmod(x, y);
      else if constexpr (is_same_v<common, long double>) return _CSTD fmodl(x, y);
    } else return x - y * static_cast<common>(static_cast<long long>(x / y));
  } else return std::fmod(static_cast<common>(x), static_cast<common>(y));
}
constexpr float fmodf(float x, float y) noexcept { return std::fmod(x, y); }
constexpr long double fmodl(long double x, long double y) noexcept { return std::fmod(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// remainder
__ywstd_cfunc_begin
extern "C" double __cdecl remainder(double, double);
extern "C" float __cdecl remainderf(float, float);
extern "C" inline long double __cdecl remainderl(long double x, long double y)
{ return _CSTD remainder(static_cast<double>(x), static_cast<double>(y)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> constexpr _common_math_t<T, U> remainder(T x, U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD remainderf(x, y);
      else if constexpr (is_same_v<common, double>) return _CSTD remainder(x, y);
      else if constexpr (is_same_v<common, long double>) return _CSTD remainderl(x, y);
    } else {
      auto quo = std::llround(x / y);
      if (std::fabs(quo - x / y) == common(0.5) && quo % 2 != 0) quo += ((quo > 0) ? -1 : 1);
      return x - quo * y;
    }
  } else return std::remainder(static_cast<common>(x), static_cast<common>(y));
}
constexpr float remainderf(float x, float y) noexcept { return std::remainder(x, y); }
constexpr long double remainderl(long double x, long double y) noexcept { return std::remainder(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// remquo
__ywstd_cfunc_begin
extern "C" double __cdecl remquo(double, double, int*);
extern "C" float __cdecl remquof(float, float, int*);
extern "C" long double __cdecl remquol(long double, long double, int*);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> [[nodiscard]]
constexpr _common_math_t<T, U> remquo(T x, U y, int* quo) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD remquof(x, y, quo);
      else if constexpr (is_same_v<common, double>) return _CSTD remquo(x, y, quo);
      else if constexpr (is_same_v<common, long double>) return _CSTD remquol(x, y, quo);
    } else {
      *quo = static_cast<int>(std::lround(x / y));
      if (std::fabs(*quo - x / y) == common(0.5) && *quo % 2 != 0) *quo += ((*quo > 0) ? -1 : 1);
      return x - *quo * y;
    }
  } else return std::remquo(static_cast<common>(x), static_cast<common>(y), quo);
}
constexpr float remquof(float x, float y, int* quo) noexcept { return std::remquo(x, y, quo); }
constexpr long double remquol(
  long double x, long double y, int* quo) noexcept { return std::remquo(x, y, quo); }
}
////////////////////////////////////////////////////////////////////////////////
// fma
__ywstd_cfunc_begin
extern "C" double __cdecl fma(double, double, double);
extern "C" float __cdecl fmaf(float, float, float);
extern "C" long double __cdecl fmal(long double, long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
/// computes `x * y + z`
template<_arithmetic T, _arithmetic U, _arithmetic V> [[nodiscard]]
constexpr _common_math_t<T, U, V> fma(T x, U y, V z) noexcept {
  using common = _common_math_t<T, U, V>;
  if constexpr (_all_the_same<common, T, U, V>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fmaf(x, y, z);
      else if constexpr (is_same_v<common, double>) return _CSTD fma(x, y, z);
      else if constexpr (is_same_v<common, long double>) return _CSTD fmal(x, y, z);
    } else return x * y + z;
  } else return std::fma(static_cast<common>(x), static_cast<common>(y), static_cast<common>(z));
}
constexpr float fmaf(float x, float y, float z) noexcept { return std::fma(x, y, z); }
constexpr long double fmal(
  long double x, long double y, long double z) noexcept { return std::fma(x, y, z); }
}
////////////////////////////////////////////////////////////////////////////////
// fmax
__ywstd_cfunc_begin
extern "C" double __cdecl fmax(double, double);
extern "C" float __cdecl fmaxf(float, float);
extern "C" long double __cdecl fmaxl(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> constexpr _common_math_t<T, U> fmax(T x, U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fmaxf(x, y);
      else if constexpr (is_same_v<common, double>) return _CSTD fmax(x, y);
      else if constexpr (is_same_v<common, long double>) return _CSTD fmaxl(x, y);
    } else return x > y ? x : y;
  } else return std::fmax(static_cast<common>(x), static_cast<common>(y));
}
constexpr float fmaxf(float x, float y) noexcept { return std::fmax(x, y); }
constexpr long double fmaxl(long double x, long double y) noexcept { return std::fmax(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// fmin
__ywstd_cfunc_begin
extern "C" double __cdecl fmin(double, double);
extern "C" float __cdecl fminf(float, float);
extern "C" long double __cdecl fminl(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> constexpr _common_math_t<T, U> fmin(T x, U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fminf(x, y);
      else if constexpr (is_same_v<common, double>) return _CSTD fmin(x, y);
      else if constexpr (is_same_v<common, long double>) return _CSTD fminl(x, y);
    } else return x < y ? x : y;
  } else return std::fmin(static_cast<common>(x), static_cast<common>(y));
}
constexpr float fminf(float x, float y) noexcept { return std::fmin(x, y); }
constexpr long double fminl(long double x, long double y) noexcept { return std::fmin(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// fdim
__ywstd_cfunc_begin
extern "C" double __cdecl fdim(double, double);
extern "C" float __cdecl fdimf(float, float);
extern "C" long double __cdecl fdiml(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> constexpr _common_math_t<T, U> fdim(T x, U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if (!is_constant_evaluated()) {
      if constexpr (is_same_v<common, float>) return _CSTD fdimf(x, y);
      else if constexpr (is_same_v<common, double>) return _CSTD fdim(x, y);
      else if constexpr (is_same_v<common, long double>) return _CSTD fdiml(x, y);
    } else return x > y ? x - y : common(0);
  } else return std::fdim(static_cast<common>(x), static_cast<common>(y));
}
constexpr float fdimf(float x, float y) noexcept { return std::fdim(x, y); }
constexpr long double fdiml(long double x, long double y) noexcept { return std::fdim(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// nan
__ywstd_cfunc_begin
extern "C" double __cdecl nan(const char*);
extern "C" float __cdecl nanf(const char*);
extern "C" long double __cdecl nanl(const char*);
__ywstd_cfunc_end
__ywstd_export namespace std {
inline float nanf(const char* tag) { return _CSTD nanf(tag); }
inline double nan(const char* tag) { return _CSTD nan(tag); }
inline long double nanl(const char* tag) { return _CSTD nanl(tag); }
}
////////////////////////////////////////////////////////////////////////////////
// lerp
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U, _arithmetic V> [[nodiscard]]
constexpr _common_math_t<T, U, V> lerp(T a, U b, V t) noexcept {
  using common = _common_math_t<T, U, V>;
  if constexpr (_all_the_same<common, T, U, V>) return std::fma(t, b - a, a);
  else return std::lerp(static_cast<common>(a), static_cast<common>(b), static_cast<common>(t));
}
}
////////////////////////////////////////////////////////////////////////////////
// exp
__ywstd_cfunc_begin
extern "C" double __cdecl exp(double);
extern "C" float __cdecl expf(float);
extern "C" inline long double __cdecl expl(long double x) { return _CSTD exp(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> exp(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD expf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD exp(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD expl(x);
  } else return std::exp(static_cast<common>(x));
}
float expf(float x) noexcept { return std::exp(x); }
long double expl(long double x) noexcept { return std::exp(x); }
}
////////////////////////////////////////////////////////////////////////////////
// exp2
__ywstd_cfunc_begin
extern "C" double __cdecl exp2(double);
extern "C" float __cdecl exp2f(float);
extern "C" long double __cdecl exp2l(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> exp2(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD exp2f(x);
    else if constexpr (is_same_v<common, double>) return _CSTD exp2(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD exp2l(x);
  } else return std::exp2(static_cast<common>(x));
}
float exp2f(float x) noexcept { return std::exp2(x); }
long double exp2l(long double x) noexcept { return std::exp2(x); }
}
////////////////////////////////////////////////////////////////////////////////
// expm1
__ywstd_cfunc_begin
extern "C" double __cdecl expm1(double);
extern "C" float __cdecl expm1f(float);
extern "C" long double __cdecl expm1l(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> expm1(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD expm1f(x);
    else if constexpr (is_same_v<common, double>) return _CSTD expm1(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD expm1l(x);
  } else return std::expm1(static_cast<common>(x));
}
float expm1f(float x) noexcept { return std::expm1(x); }
long double expm1l(long double x) noexcept { return std::expm1(x); }
}
////////////////////////////////////////////////////////////////////////////////
// log
__ywstd_cfunc_begin
extern "C" double __cdecl log(double);
extern "C" float __cdecl logf(float);
extern "C" inline long double __cdecl logl(long double x) { return _CSTD log(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> log(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD logf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD log(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD logl(x);
  } else return std::log(static_cast<common>(x));
}
float logf(float x) noexcept { return std::log(x); }
long double logl(long double x) noexcept { return std::log(x); }
}
////////////////////////////////////////////////////////////////////////////////
// log2
__ywstd_cfunc_begin
extern "C" double __cdecl log2(double);
extern "C" float __cdecl log2f(float);
extern "C" long double __cdecl log2l(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> log2(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD log2f(x);
    else if constexpr (is_same_v<common, double>) return _CSTD log2(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD log2l(x);
  } else return std::log2(static_cast<common>(x));
}
float log2f(float x) noexcept { return std::log2(x); }
long double log2l(long double x) noexcept { return std::log2(x); }
}
////////////////////////////////////////////////////////////////////////////////
// log10
__ywstd_cfunc_begin
extern "C" double __cdecl log10(double);
extern "C" float __cdecl log10f(float);
extern "C" inline long double __cdecl log10l(long double x) { return _CSTD log10(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> log10(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD log10f(x);
    else if constexpr (is_same_v<common, double>) return _CSTD log10(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD log10l(x);
  } else return std::log10(static_cast<common>(x));
}
float log10f(float x) noexcept { return std::log10(x); }
long double log10l(long double x) noexcept { return std::log10(x); }
}
////////////////////////////////////////////////////////////////////////////////
// log1p
__ywstd_cfunc_begin
extern "C" double __cdecl log1p(double);
extern "C" float __cdecl log1pf(float);
extern "C" long double __cdecl log1pl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> log1p(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD log1pf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD log1p(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD log1pl(x);
  } else return std::log1p(static_cast<common>(x));
}
float log1pf(float x) noexcept { return std::log1p(x); }
long double log1pl(long double x) noexcept { return std::log1p(x); }
}
////////////////////////////////////////////////////////////////////////////////
// sqrt
__ywstd_cfunc_begin
extern "C" double __cdecl sqrt(double);
extern "C" float __cdecl sqrtf(float);
extern "C" inline long double __cdecl sqrtl(long double x) { return _CSTD sqrt(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> sqrt(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD sqrtf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD sqrt(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD sqrtl(x);
  } else return std::sqrt(static_cast<common>(x));
}
float sqrtf(float x) noexcept { return std::sqrt(x); }
long double sqrtl(long double x) noexcept { return std::sqrt(x); }
}
////////////////////////////////////////////////////////////////////////////////
// cbrt
__ywstd_cfunc_begin
extern "C" double __cdecl cbrt(double);
extern "C" float __cdecl cbrtf(float);
extern "C" long double __cdecl cbrtl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> cbrt(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD cbrtf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD cbrt(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD cbrtl(x);
  } else return std::cbrt(static_cast<common>(x));
}
float cbrtf(float x) noexcept { return std::cbrt(x); }
long double cbrtl(long double x) noexcept { return std::cbrt(x); }
}
////////////////////////////////////////////////////////////////////////////////
// hypot
__ywstd_cfunc_begin
extern "C" double __cdecl hypot(double, double);
extern "C" inline float __cdecl hypotf(float x, float y) { return static_cast<float>(_CSTD hypot(x, y)); }
extern "C" inline long double __cdecl hypotl(long double x, long double y)
{ return _CSTD hypot(static_cast<double>(x), static_cast<double>(y)); }
float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
double __stdcall __std_smf_hypot3(double, double, double) noexcept;
inline long double __stdcall __std_smf_hypot3l(long double x, long double y, long double z) noexcept
{ return _CSTD __std_smf_hypot3(static_cast<double>(x), static_cast<double>(y), static_cast<double>(z)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> hypot(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD hypotf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD hypot(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD hypotl(x, y);
  } else return std::hypot(static_cast<common>(x), static_cast<common>(y));
}
template<_arithmetic T, _arithmetic U, _arithmetic V> [[nodiscard]]
_common_math_t<T, U, V> hypot(const T x, const U y, const V z) noexcept {
  using common = _common_math_t<T, U, V>;
  if constexpr (_all_the_same<common, T, U, V>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_hypot3f(x, y, z);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_hypot3(x, y, z);
    else if constexpr (is_same_v<common, long double>) return _CSTD __std_smf_hypot3l(x, y, z);
  } else return std::hypot(static_cast<common>(x), std::hypot(static_cast<common>(y), static_cast<common>(z)));
}
float hypotf(float x, float y) noexcept { return std::hypot(x, y); }
long double hypotl(long double x, long double y) noexcept { return std::hypot(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// pow
__ywstd_cfunc_begin
extern "C" double __cdecl pow(double, double);
extern "C" float __cdecl powf(float, float);
extern "C" inline long double __cdecl powl(long double x, long double y)
{ return _CSTD pow(static_cast<double>(x), static_cast<double>(y)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> pow(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD powf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD pow(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD powl(x, y);
  } else return std::pow(static_cast<common>(x), static_cast<common>(y));
}
float powf(float x, float y) noexcept { return std::pow(x, y); }
long double powl(long double x, long double y) noexcept { return std::pow(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// sin
__ywstd_cfunc_begin
extern "C" double __cdecl sin(double);
extern "C" float __cdecl sinf(float);
extern "C" inline long double __cdecl sinl(long double x) { return _CSTD sin(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> sin(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD sinf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD sin(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD sinl(x);
  } else return std::sin(static_cast<common>(x));
}
float sinf(float x) noexcept { return std::sin(x); }
long double sinl(long double x) noexcept { return std::sin(x); }
}
////////////////////////////////////////////////////////////////////////////////
// cos
__ywstd_cfunc_begin
extern "C" double __cdecl cos(double);
extern "C" float __cdecl cosf(float);
extern "C" inline long double __cdecl cosl(long double x) { return _CSTD cos(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> cos(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD cosf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD cos(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD cosl(x);
  } else return std::cos(static_cast<common>(x));
}
float cosf(float x) noexcept { return std::cos(x); }
long double cosl(long double x) noexcept { return std::cos(x); }
}
////////////////////////////////////////////////////////////////////////////////
// tan
__ywstd_cfunc_begin
extern "C" double __cdecl tan(double);
extern "C" float __cdecl tanf(float);
extern "C" inline long double __cdecl tanl(long double x) { return _CSTD tan(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> tan(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD tanf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD tan(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD tanl(x);
  } else return std::tan(static_cast<common>(x));
}
float tanf(float x) noexcept { return std::tan(x); }
long double tanl(long double x) noexcept { return std::tan(x); }
}
////////////////////////////////////////////////////////////////////////////////
// asin
__ywstd_cfunc_begin
extern "C" double __cdecl asin(double);
extern "C" float __cdecl asinf(float);
extern "C" inline long double __cdecl asinl(long double x) { return _CSTD asin(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> asin(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD asinf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD asin(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD asinl(x);
  } else return std::asin(static_cast<common>(x));
}
float asinf(float x) noexcept { return std::asin(x); }
long double asinl(long double x) noexcept { return std::asin(x); }
}
////////////////////////////////////////////////////////////////////////////////
// acos
__ywstd_cfunc_begin
extern "C" double __cdecl acos(double);
extern "C" float __cdecl acosf(float);
extern "C" inline long double __cdecl acosl(long double x) { return _CSTD acos(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> acos(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD acosf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD acos(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD acosl(x);
  } else return std::acos(static_cast<common>(x));
}
float acosf(float x) noexcept { return std::acos(x); }
long double acosl(long double x) noexcept { return std::acos(x); }
}
////////////////////////////////////////////////////////////////////////////////
// atan
__ywstd_cfunc_begin
extern "C" double __cdecl atan(double);
extern "C" float __cdecl atanf(float);
extern "C" inline long double __cdecl atanl(long double x) { return _CSTD atan(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> atan(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD atanf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD atan(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD atanl(x);
  } else return std::atan(static_cast<common>(x));
}
float atanf(float x) noexcept { return std::atan(x); }
long double atanl(long double x) noexcept { return std::atan(x); }
}
////////////////////////////////////////////////////////////////////////////////
// atan2
__ywstd_cfunc_begin
extern "C" double __cdecl atan2(double, double);
extern "C" float __cdecl atan2f(float, float);
extern "C" inline long double __cdecl atan2l(long double x, long double y)
{ return _CSTD atan2(static_cast<double>(x), static_cast<double>(y)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> atan2(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD atan2f(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD atan2(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD atan2l(x, y);
  } else return std::atan2(static_cast<common>(x), static_cast<common>(y));
}
float atan2f(float x, float y) noexcept { return std::atan2(x, y); }
long double atan2l(long double x, long double y) noexcept { return std::atan2(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// sinh
__ywstd_cfunc_begin
extern "C" double __cdecl sinh(double);
extern "C" float __cdecl sinhf(float);
extern "C" inline long double __cdecl sinhl(long double x) { return _CSTD sinh(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> sinh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD sinhf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD sinh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD sinhl(x);
  } else return std::sinh(static_cast<common>(x));
}
float sinhf(float x) noexcept { return std::sinh(x); }
long double sinhl(long double x) noexcept { return std::sinh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// cosh
__ywstd_cfunc_begin
extern "C" double __cdecl cosh(double);
extern "C" float __cdecl coshf(float);
extern "C" inline long double __cdecl coshl(long double x) { return _CSTD cosh(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> cosh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD coshf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD cosh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD coshl(x);
  } else return std::cosh(static_cast<common>(x));
}
float coshf(float x) noexcept { return std::cosh(x); }
long double coshl(long double x) noexcept { return std::cosh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// tanh
__ywstd_cfunc_begin
extern "C" double __cdecl tanh(double);
extern "C" float __cdecl tanhf(float);
extern "C" inline long double __cdecl tanhl(long double x) { return _CSTD tanh(static_cast<double>(x)); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> tanh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD tanhf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD tanh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD tanhl(x);
  } else return std::tanh(static_cast<common>(x));
}
float tanhf(float x) noexcept { return std::tanh(x); }
long double tanhl(long double x) noexcept { return std::tanh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// asinh
__ywstd_cfunc_begin
extern "C" double __cdecl asinh(double);
extern "C" float __cdecl asinhf(float);
extern "C" long double __cdecl asinhl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> asinh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD asinhf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD asinh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD asinhl(x);
  } else return std::asinh(static_cast<common>(x));
}
float asinhf(float x) noexcept { return std::asinh(x); }
long double asinhl(long double x) noexcept { return std::asinh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// acosh
__ywstd_cfunc_begin
extern "C" double __cdecl acosh(double);
extern "C" float __cdecl acoshf(float);
extern "C" long double __cdecl acoshl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> acosh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD acoshf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD acosh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD acoshl(x);
  } else return std::acosh(static_cast<common>(x));
}
float acoshf(float x) noexcept { return std::acosh(x); }
long double acoshl(long double x) noexcept { return std::acosh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// atanh
__ywstd_cfunc_begin
extern "C" double __cdecl atanh(double);
extern "C" float __cdecl atanhf(float);
extern "C" long double __cdecl atanhl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> atanh(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD atanhf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD atanh(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD atanhl(x);
  } else return std::atanh(static_cast<common>(x));
}
float atanhf(float x) noexcept { return std::atanh(x); }
long double atanhl(long double x) noexcept { return std::atanh(x); }
}
////////////////////////////////////////////////////////////////////////////////
// erf
__ywstd_cfunc_begin
extern "C" double __cdecl erf(double);
extern "C" float __cdecl erff(float);
extern "C" long double __cdecl erfl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> erf(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD erff(x);
    else if constexpr (is_same_v<common, double>) return _CSTD erf(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD erfl(x);
  } else return std::erf(static_cast<common>(x));
}
float erff(float x) noexcept { return std::erf(x); }
long double erfl(long double x) noexcept { return std::erf(x); }
}
////////////////////////////////////////////////////////////////////////////////
// erfc
__ywstd_cfunc_begin
extern "C" double __cdecl erfc(double);
extern "C" float __cdecl erfcf(float);
extern "C" long double __cdecl erfcl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> erfc(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD erfcf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD erfc(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD erfcl(x);
  } else return std::erfc(static_cast<common>(x));
}
float erfcf(float x) noexcept { return std::erfc(x); }
long double erfcl(long double x) noexcept { return std::erfc(x); }
}
////////////////////////////////////////////////////////////////////////////////
// tgamma
__ywstd_cfunc_begin
extern "C" double __cdecl tgamma(double);
extern "C" float __cdecl tgammaf(float);
extern "C" long double __cdecl tgammal(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> tgamma(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD tgammaf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD tgamma(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD tgammal(x);
  } else return std::tgamma(static_cast<common>(x));
}
float tgammaf(float x) noexcept { return std::tgamma(x); }
long double tgammal(long double x) noexcept { return std::tgamma(x); }
}
////////////////////////////////////////////////////////////////////////////////
// lgamma
__ywstd_cfunc_begin
extern "C" double __cdecl lgamma(double);
extern "C" float __cdecl lgammaf(float);
extern "C" long double __cdecl lgammal(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> lgamma(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD lgammaf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD lgamma(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD lgammal(x);
  } else return std::lgamma(static_cast<common>(x));
}
float lgammaf(float x) noexcept { return std::lgamma(x); }
long double lgammal(long double x) noexcept { return std::lgamma(x); }
}
////////////////////////////////////////////////////////////////////////////////
// frexp
__ywstd_cfunc_begin
extern "C" double __cdecl frexp(double, int*);
extern "C" inline float __cdecl frexpf(float x, int* exp) { return static_cast<float>(_CSTD frexp(x, exp)); }
extern "C" inline long double __cdecl frexpl(long double x, int* exp) { return _CSTD frexp(static_cast<double>(x), exp); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> frexp(const T x, int* exp) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD frexpf(x, exp);
    else if constexpr (is_same_v<common, double>) return _CSTD frexp(x, exp);
    else if constexpr (is_same_v<common, long double>) return _CSTD frexpl(x, exp);
  } else return std::frexp(static_cast<common>(x), exp);
}
float frexpf(float x, int* exp) noexcept { return std::frexp(x, exp); }
long double frexpl(long double x, int* exp) noexcept { return std::frexp(x, exp); }
}
////////////////////////////////////////////////////////////////////////////////
// ldexp
__ywstd_cfunc_begin
extern "C" double __cdecl ldexp(double, int);
extern "C" inline float __cdecl ldexpf(float x, int exp) { return static_cast<float>(_CSTD ldexp(x, exp)); }
extern "C" inline long double __cdecl ldexpl(long double x, int exp) { return _CSTD ldexp(static_cast<double>(x), exp); }
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> ldexp(const T x, const int exp) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD ldexpf(x, exp);
    else if constexpr (is_same_v<common, double>) return _CSTD ldexp(x, exp);
    else if constexpr (is_same_v<common, long double>) return _CSTD ldexpl(x, exp);
  } else return std::ldexp(static_cast<common>(x), exp);
}
float ldexpf(float x, int exp) noexcept { return std::ldexp(x, exp); }
long double ldexpl(long double x, int exp) noexcept { return std::ldexp(x, exp); }
}
////////////////////////////////////////////////////////////////////////////////
// scalbn
__ywstd_cfunc_begin
extern "C" double __cdecl scalbn(double, int);
extern "C" float __cdecl scalbnf(float, int);
extern "C" long double __cdecl scalbnl(long double, int);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> scalbn(const T x, const int n) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD scalbnf(x, n);
    else if constexpr (is_same_v<common, double>) return _CSTD scalbn(x, n);
    else if constexpr (is_same_v<common, long double>) return _CSTD scalbnl(x, n);
  } else return std::scalbn(static_cast<common>(x), n);
}
float scalbnf(float x, int n) noexcept { return std::scalbn(x, n); }
long double scalbnl(long double x, int n) noexcept { return std::scalbn(x, n); }
}
////////////////////////////////////////////////////////////////////////////////
// scalbln
__ywstd_cfunc_begin
extern "C" double __cdecl scalbln(double, long);
extern "C" float __cdecl scalblnf(float, long);
extern "C" long double __cdecl scalblnl(long double, long);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> scalbln(const T x, const long n) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD scalblnf(x, n);
    else if constexpr (is_same_v<common, double>) return _CSTD scalbln(x, n);
    else if constexpr (is_same_v<common, long double>) return _CSTD scalblnl(x, n);
  } else return std::scalbln(static_cast<common>(x), n);
}
float scalblnf(float x, long n) noexcept { return std::scalbln(x, n); }
long double scalblnl(long double x, long n) noexcept { return std::scalbln(x, n); }
}
////////////////////////////////////////////////////////////////////////////////
// logb
__ywstd_cfunc_begin
extern "C" double __cdecl logb(double);
extern "C" float __cdecl logbf(float);
extern "C" long double __cdecl logbl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> logb(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD logbf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD logb(x);
    else if constexpr (is_same_v<common, long double>) return _CSTD logbl(x);
  } else return std::logb(static_cast<common>(x));
}
float logbf(float x) noexcept { return std::logb(x); }
long double logbl(long double x) noexcept { return std::logb(x); }
}
////////////////////////////////////////////////////////////////////////////////
// ilogb
__ywstd_cfunc_begin
extern "C" int __cdecl ilogb(double);
extern "C" int __cdecl ilogbf(float);
extern "C" int __cdecl ilogbl(long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> int ilogb(const T x) noexcept {
  if constexpr (is_same_v<T, float>) return _CSTD ilogbf(x);
  else if constexpr (is_same_v<T, double>) return _CSTD ilogb(x);
  else if constexpr (is_same_v<T, long double>) return _CSTD ilogbl(x);
  else return std::ilogb(static_cast<_common_math_t<T>>(x));
}
int ilogbf(float x) noexcept { return std::ilogb(x); }
int ilogbl(long double x) noexcept { return std::ilogb(x); }
}
////////////////////////////////////////////////////////////////////////////////
// nextafter
__ywstd_cfunc_begin
extern "C" double __cdecl nextafter(double, double);
extern "C" float __cdecl nextafterf(float, float);
extern "C" long double __cdecl nextafterl(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> nextafter(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD nextafterf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD nextafter(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD nextafterl(x, y);
  } else return std::nextafter(static_cast<common>(x), static_cast<common>(y));
}
float nextafterf(float x, float y) noexcept { return std::nextafter(x, y); }
long double nextafterl(long double x, long double y) noexcept { return std::nextafter(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// nexttoward
__ywstd_cfunc_begin
extern "C" double __cdecl nexttoward(double, long double);
extern "C" float __cdecl nexttowardf(float, long double);
extern "C" long double __cdecl nexttowardl(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> nexttoward(const T x, long double y) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD nexttowardf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD nexttoward(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD nexttowardl(x, y);
  } else return std::nexttoward(static_cast<common>(x), static_cast<common>(y));
}
float nexttowardf(float x, long double y) noexcept { return std::nexttoward(x, y); }
long double nexttowardl(long double x, long double y) noexcept { return std::nexttoward(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// copysign
__ywstd_cfunc_begin
extern "C" double __cdecl copysign(double, double);
extern "C" float __cdecl copysignf(float, float);
extern "C" long double __cdecl copysignl(long double, long double);
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> copysign(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD copysignf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD copysign(x, y);
    else if constexpr (is_same_v<common, long double>) return _CSTD copysignl(x, y);
  } else return std::copysign(static_cast<common>(x), static_cast<common>(y));
}
float copysignf(float x, float y) noexcept { return std::copysign(x, y); }
long double copysignl(long double x, long double y) noexcept { return std::copysign(x, y); }
}
////////////////////////////////////////////////////////////////////////////////
// assoc_laguerre, assoc_legendre
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_assoc_laguerref(unsigned, unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_assoc_laguerre(unsigned, unsigned, double) noexcept;
extern "C" float __stdcall __std_smf_assoc_legendref(unsigned, unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_assoc_legendre(unsigned, unsigned, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> [[nodiscard]]
_common_math_t<T> assoc_laguerre(const unsigned n, const unsigned m, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_assoc_laguerref(n, m, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_assoc_laguerre(n, m, x);
    else return _CSTD __std_smf_assoc_laguerre(n, m, static_cast<double>(x));
  } else return std::assoc_laguerre(n, m, static_cast<common>(x));
}
template<_arithmetic T> [[nodiscard]]
_common_math_t<T> assoc_legendre(const unsigned n, const unsigned m, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_assoc_legendref(n, m, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_assoc_legendre(n, m, x);
    else return _CSTD __std_smf_assoc_legendre(n, m, static_cast<double>(x));
  } else return std::assoc_legendre(n, m, static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// beta
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_betaf(float, float) noexcept;
extern "C" double __stdcall __std_smf_beta(double, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> beta(const T x, const U y) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_betaf(x, y);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_beta(x, y);
    else return _CSTD __std_smf_beta(static_cast<double>(x), static_cast<double>(y));
  } else return std::beta(static_cast<common>(x), static_cast<common>(y));
}
}
////////////////////////////////////////////////////////////////////////////////
// comp_ellint_1, comp_ellint_2, comp_ellint_3
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
extern "C" double __stdcall __std_smf_comp_ellint_1(double) noexcept;
extern "C" float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
extern "C" double __stdcall __std_smf_comp_ellint_2(double) noexcept;
extern "C" float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
extern "C" double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> comp_ellint_1(const T k) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_comp_ellint_1f(k);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_comp_ellint_1(k);
    else return _CSTD __std_smf_comp_ellint_1(static_cast<double>(k));
  } else return std::comp_ellint_1(static_cast<common>(k));
}
template<_arithmetic T> _common_math_t<T> comp_ellint_2(const T k) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_comp_ellint_2f(k);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_comp_ellint_2(k);
    else return _CSTD __std_smf_comp_ellint_2(static_cast<double>(k));
  } else return std::comp_ellint_2(static_cast<common>(k));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> comp_ellint_3(const T k, const U n) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_comp_ellint_3f(k, n);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_comp_ellint_3(k, n);
    else return _CSTD __std_smf_comp_ellint_3(static_cast<double>(k), static_cast<double>(n));
  } else return std::comp_ellint_3(static_cast<common>(k), static_cast<common>(n));
}
}
////////////////////////////////////////////////////////////////////////////////
// cyl_bessel_i, cyl_bessel_j, cyl_bessel_k, cyl_neumann
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
extern "C" double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
extern "C" float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
extern "C" double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
extern "C" float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
extern "C" double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
extern "C" float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
extern "C" double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> cyl_bessel_i(const T n, const U x) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_cyl_bessel_if(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_cyl_bessel_i(n, x);
    else return _CSTD __std_smf_cyl_bessel_i(static_cast<double>(n), static_cast<double>(x));
  } else return std::cyl_bessel_i(static_cast<common>(n), static_cast<common>(x));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> cyl_bessel_j(const T n, const U x) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_cyl_bessel_jf(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_cyl_bessel_j(n, x);
    else return _CSTD __std_smf_cyl_bessel_j(static_cast<double>(n), static_cast<double>(x));
  } else return std::cyl_bessel_j(static_cast<common>(n), static_cast<common>(x));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> cyl_bessel_k(const T n, const U x) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_cyl_bessel_kf(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_cyl_bessel_k(n, x);
    else return _CSTD __std_smf_cyl_bessel_k(static_cast<double>(n), static_cast<double>(x));
  } else return std::cyl_bessel_k(static_cast<common>(n), static_cast<common>(x));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> cyl_neumann(const T n, const U x) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_cyl_neumannf(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_cyl_neumann(n, x);
    else return _CSTD __std_smf_cyl_neumann(static_cast<double>(n), static_cast<double>(x));
  } else return std::cyl_neumann(static_cast<common>(n), static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// ellint_1, ellint_2, ellint_3
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_ellint_1f(float, float) noexcept;
extern "C" double __stdcall __std_smf_ellint_1(double, double) noexcept;
extern "C" float __stdcall __std_smf_ellint_2f(float, float) noexcept;
extern "C" double __stdcall __std_smf_ellint_2(double, double) noexcept;
extern "C" float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
extern "C" double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> ellint_1(const T k, const U phi) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_ellint_1f(k, phi);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_ellint_1(k, phi);
    else return _CSTD __std_smf_ellint_1(static_cast<double>(k), static_cast<double>(phi));
  } else return std::ellint_1(static_cast<common>(k), static_cast<common>(phi));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> ellint_2(const T k, const U phi) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_ellint_2f(k, phi);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_ellint_2(k, phi);
    else return _CSTD __std_smf_ellint_2(static_cast<double>(k), static_cast<double>(phi));
  } else return std::ellint_2(static_cast<common>(k), static_cast<common>(phi));
}
template<_arithmetic T, _arithmetic U> _common_math_t<T, U> ellint_3(const T k, const U n, const U phi) noexcept {
  using common = _common_math_t<T, U>;
  if constexpr (_all_the_same<common, T, U>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_ellint_3f(k, n, phi);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_ellint_3(k, n, phi);
    else return _CSTD __std_smf_ellint_3(static_cast<double>(k), static_cast<double>(n), static_cast<double>(phi));
  } else return std::ellint_3(static_cast<common>(k), static_cast<common>(n), static_cast<common>(phi));
}
}
////////////////////////////////////////////////////////////////////////////////
// expint
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_expintf(float) noexcept;
extern "C" double __stdcall __std_smf_expint(double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> expint(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_expintf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_expint(x);
    else return _CSTD __std_smf_expint(static_cast<double>(x));
  } else return std::expint(static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// hermite
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_hermitef(unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_hermite(unsigned, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> hermite(const unsigned n, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_hermitef(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_hermite(n, x);
    else return _CSTD __std_smf_hermite(n, static_cast<double>(x));
  } else return std::hermite(n, static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// laguerre
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_laguerref(unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_laguerre(unsigned, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> laguerre(const unsigned n, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_laguerref(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_laguerre(n, x);
    else return _CSTD __std_smf_laguerre(n, static_cast<double>(x));
  } else return std::laguerre(n, static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// legendre
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_legendref(unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_legendre(unsigned, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> legendre(const unsigned n, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_legendref(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_legendre(n, x);
    else return _CSTD __std_smf_legendre(n, static_cast<double>(x));
  } else return std::legendre(n, static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// riemann_zeta
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_riemann_zetaf(float) noexcept;
extern "C" double __stdcall __std_smf_riemann_zeta(double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> riemann_zeta(const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_riemann_zetaf(x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_riemann_zeta(x);
    else return _CSTD __std_smf_riemann_zeta(static_cast<double>(x));
  } else return std::riemann_zeta(static_cast<common>(x));
}
}
////////////////////////////////////////////////////////////////////////////////
// sph_bessel, sph_legendre, sph_neumann
__ywstd_cfunc_begin
extern "C" float __stdcall __std_smf_sph_besself(unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_sph_bessel(unsigned, double) noexcept;
extern "C" float __stdcall __std_smf_sph_legendref(unsigned, unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_sph_legendre(unsigned, unsigned, double) noexcept;
extern "C" float __stdcall __std_smf_sph_neumannf(unsigned, float) noexcept;
extern "C" double __stdcall __std_smf_sph_neumann(unsigned, double) noexcept;
__ywstd_cfunc_end
__ywstd_export namespace std {
template<_arithmetic T> _common_math_t<T> sph_bessel(const unsigned n, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_sph_besself(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_sph_bessel(n, x);
    else return _CSTD __std_smf_sph_bessel(n, static_cast<double>(x));
  } else return std::sph_bessel(n, static_cast<common>(x));
}
template<_arithmetic T> [[nodiscard]]
_common_math_t<T> sph_legendre(const unsigned l, const unsigned m, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_sph_legendref(l, m, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_sph_legendre(l, m, x);
    else return _CSTD __std_smf_sph_legendre(l, m, static_cast<double>(x));
  } else return std::sph_legendre(l, m, static_cast<common>(x));
}
template<_arithmetic T> _common_math_t<T> sph_neumann(const unsigned n, const T x) noexcept {
  using common = _common_math_t<T>;
  if constexpr (_all_the_same<common, T>) {
    if constexpr (is_same_v<common, float>) return _CSTD __std_smf_sph_neumannf(n, x);
    else if constexpr (is_same_v<common, double>) return _CSTD __std_smf_sph_neumann(n, x);
    else return _CSTD __std_smf_sph_neumann(n, static_cast<double>(x));
  } else return std::sph_neumann(n, static_cast<common>(x));
}
}
