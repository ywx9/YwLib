#pragma once
#include "abc.h"

#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2
#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)

#define FP_INFINITE 1
#define FP_NAN 2
#define FP_NORMAL (-1)
#define FP_SUBNORMAL (-2)
#define FP_ZERO 0

#define INFINITY (static_cast<float>(1e300 * 1e300))
#define NAN (-static_cast<float>(INFINITY * 0.0f))
#define HUGE_VAL (static_cast<double>(INFINITY))
#define HUGE_VALF (static_cast<float>(INFINITY))
#define HUGE_VALL (static_cast<long double>(INFINITY))

extern "C" {
__ywlib_begin;

using float_t = float;
using double_t = double;

short __cdecl _dtest(double*);
short __cdecl _fdtest(float*);
short __cdecl _ldtest(long double*);

int __cdecl _dsign(double);
int __cdecl _fdsign(float);
int __cdecl _ldsign(long double);

int __cdecl _dpcomp(double, double);
int __cdecl _fdpcomp(float, float);
int __cdecl _ldpcomp(long double, long double);

double __cdecl nan(char const*);
float __cdecl nanf(char const*);
long double __cdecl nanl(char const*);

__ywlib_end;
}
namespace ywlib::cmath {
template<typename... Ts> using common = decltype((yw::select_type<yw::integral<Ts>, double, Ts>{} + ...));
template<typename T> constexpr int fpcomp(T x, T y) noexcept {
  if (!yw::is_cev) {
    if constexpr (yw::same_as<T, float>) return __ywlib_global _fdpcomp(x, y);
    else if constexpr (yw::same_as<T, double>) return __ywlib_global _dpcomp(x, y);
    else if constexpr (yw::same_as<T, long double>) return __ywlib_global _ldpcomp(x, y);
  } else return (x < y ? 1 : 0) | (x == y ? 2 : 0) | (x > y ? 4 : 0);
}
}

#if not __ywlib_is_imported
export namespace std {

using __ywlib_global float_t;
using __ywlib_global double_t;

template<typename T, typename U> using _Common_float_type_t = ywlib::cmath::common<float, T, U>;
template<yw::arithmetic T> constexpr int fpclassify(T x) noexcept {
  if constexpr (yw::float_type<T>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<T, float>) return __ywlib_global _fdtest(&x);
      else if constexpr (yw::same_as<T, double>) return __ywlib_global _dtest(&x);
      else if constexpr (yw::same_as<T, long double>) return __ywlib_global _ldtest(&x);
    } else {
      using ut = yw::select_type<sizeof(T) == 4, unsigned, unsigned long long>;
      constexpr ut exp_mask = static_cast<ut>(sizeof(ut) == 4 ? 0x7F800000 : 0x7FF0000000000000);
      if (x == T(0)) return FP_ZERO;
      else if (const ut u = __builtin_bit_cast(ut, x); ((u & exp_mask) | exp_mask) == 0) return FP_SUBNORMAL;
      else if ((u & exp_mask) == exp_mask) return (u & ~exp_mask) == 0 ? FP_INFINITE : FP_NAN;
      else return FP_NORMAL;
    }
  } else return std::fpclassify(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isfinite(const T x) noexcept {
  if constexpr (yw::float_type<T>) {
    const auto fp = fpclassify(x);
    return fp != FP_INFINITE && fp != FP_NAN;
  } else return std::isfinite(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isinf(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_INFINITE;
  else return std::isinf(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isnan(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_NAN;
  else return std::isnan(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isnormal(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_NORMAL;
  else return std::isnormal(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool signbit(const T x) noexcept {
  if constexpr (yw::float_type<T>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<T, float>) return __ywlib_global _fdsign(x);
      else if constexpr (yw::same_as<T, double>) return __ywlib_global _dsign(x);
      else if constexpr (yw::same_as<T, long double>) return __ywlib_global _ldsign(x);
    } else return x < T(0);
  } else if constexpr (yw::signed_integral<T>) return x < T(0);
  else return false;
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool isgreater(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) & 4;
  else return std::isgreater(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool isgreaterequal(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) & 6;
  else return std::isgreaterequal(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool isless(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) & 1;
  else return std::isless(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool islessequal(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) & 3;
  else return std::islessequal(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool islessgreater(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) & 5;
  else return std::islessgreater(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U> constexpr bool isunordered(const T x, const U y) noexcept {
  using common = ywlib::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywlib::cmath::fpcomp(x, y) == 0;
  else return std::isunordered(static_cast<double>(x), static_cast<double>(y));
}
inline float nanf(const char* tag) { return __ywlib_global nanf(tag); }
inline double nan(const char* tag) { return __ywlib_global nan(tag); }
inline long double nanl(const char* tag) { return __ywlib_global nanl(tag); }
}
#endif

namespace ywlib::cmath {
template<typename T> constexpr T fabs(T x) noexcept { return x < 0 ? -x : x; }
template<typename T> constexpr T ceil(T x) noexcept {
  const auto i = static_cast<T>(static_cast<long long>(x));
  return i == x ? x : (x < 0 ? i : i + 1);
}
template<typename T> constexpr T floor(T x) noexcept {
  const auto i = static_cast<T>(static_cast<long long>(x));
  return i == x ? x : (x < 0 ? i - 1 : i);
}
template<typename T> constexpr T trunc(T x) noexcept { return static_cast<T>(static_cast<long long>(x)); }
template<typename T> constexpr T round(T x) noexcept { return trunc(static_cast<T>(x < 0 ? x - 0.5 : x + 0.5)); }
template<typename T> constexpr long lround(T x) noexcept { return static_cast<long>(round(x)); }
template<typename T> constexpr long long llround(T x) noexcept { return static_cast<long long>(round(x)); }
}

#if not __ywlib_is_imported
#define __ywlib_cmath_c1(fn, rt, rtf, rtl)                                            \
  extern "C" {                                                                        \
  __ywlib_begin;                                                                      \
  rt __cdecl fn(double);                                                              \
  rtf __cdecl fn##f(float);                                                           \
  rtl __cdecl fn##l(long double);                                                     \
  __ywlib_end;                                                                        \
  }                                                                                   \
  __ywlib_export namespace std {                                                      \
    template<yw::arithmetic T> constexpr auto fn(const T x) noexcept {                \
      using common = ywlib::cmath::common<T>;                                         \
      if constexpr (yw::same_as<common, T>) {                                         \
        if (!yw::is_cev) {                                                            \
          if constexpr (yw::same_as<common, float>) return __ywlib_global fn##f(x);    \
          else if constexpr (yw::same_as<common, double>) return __ywlib_global fn(x); \
          else return __ywlib_global fn##l(x);                                         \
        } else return ywlib::cmath::fn(x);                                            \
      } else return std::fn(static_cast<common>(x));                                  \
    }                                                                                 \
    constexpr auto fn##f(float x) noexcept { return std::fn(x); }                     \
    constexpr auto fn##l(long double x) noexcept { return std::fn(x); }               \
  }
#else
#define __ywlib_cmath_c1(...)
#endif

__ywlib_cmath_c1(fabs, double, float, long double);
__ywlib_cmath_c1(ceil, double, float, long double);
__ywlib_cmath_c1(floor, double, float, long double);
__ywlib_cmath_c1(trunc, double, float, long double);
__ywlib_cmath_c1(round, double, float, long double);
__ywlib_cmath_c1(lround, long, long, long);
__ywlib_cmath_c1(llround, long long, long long, long long);

namespace ywlib::cmath {
template<typename T> constexpr T copysign(T mag, T sgn) noexcept { return fabs(mag) * (sgn < 0 ? -1 : 1); }
template<typename T> constexpr T fmod(T x, T y) noexcept { return x - y * static_cast<T>(static_cast<long long>(x / y)); }
template<typename T> constexpr T remainder(T x, T y) noexcept {
  auto quo = std::llround(x / y);
  if (std::fabs(quo - x / y) == T(0.5) && quo % 2 != 0) quo += (quo > 0) ? -1 : 1;
  return x - quo * y;
}
template<typename T> constexpr T fmax(T x, T y) noexcept { return x > y ? x : y; }
template<typename T> constexpr T fmin(T x, T y) noexcept { return x < y ? x : y; }
template<typename T> constexpr T fdim(T x, T y) noexcept { return fmax(x - y, T(0)); }
}

#if not __ywlib_is_imported
#define __ywlib_cmath_c2(fn, rt, rtf, rtl)                                                          \
  extern "C" {                                                                                      \
  __ywlib_begin;                                                                                    \
  rt __cdecl fn(double, double);                                                                    \
  rtf __cdecl fn##f(float, float);                                                                  \
  rtl __cdecl fn##l(long double, long double);                                                      \
  __ywlib_end;                                                                                      \
  }                                                                                                 \
  __ywlib_export namespace std {                                                                    \
    template<yw::arithmetic T, yw::arithmetic U> constexpr auto fn(const T x, const U y) noexcept { \
      using common = ywlib::cmath::common<T, U>;                                                    \
      if constexpr (yw::same_as<common, T, U>) {                                                    \
        if (!yw::is_cev) {                                                                          \
          if constexpr (yw::same_as<common, float>) return __ywlib_global fn##f(x, y);               \
          else if constexpr (yw::same_as<common, double>) return __ywlib_global fn(x, y);            \
          else return __ywlib_global fn##l(x, y);                                                    \
        } else return ywlib::cmath::fn(x, y);                                                       \
      } else return std::fn(static_cast<common>(x), static_cast<common>(y));                        \
    }                                                                                               \
    constexpr auto fn##f(float x, float y) noexcept { return std::fn(x, y); }                       \
    constexpr auto fn##l(long double x, long double y) noexcept { return std::fn(x, y); }           \
  }
#else
#define __ywlib_cmath_c2(...)
#endif

__ywlib_cmath_c2(copysign, double, float, long double);
__ywlib_cmath_c2(fmod, double, float, long double);
__ywlib_cmath_c2(remainder, double, float, long double);
__ywlib_cmath_c2(fmax, double, float, long double);
__ywlib_cmath_c2(fmin, double, float, long double);
__ywlib_cmath_c2(fdim, double, float, long double);

extern "C" {
__ywlib_begin;
double __cdecl fma(double, double, double);
float __cdecl fmaf(float, float, float);
long double __cdecl fmal(long double, long double, long double);
__ywlib_end;
}
#if not __ywlib_is_imported
__ywlib_export namespace std {
  template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V> constexpr ywlib::cmath::common<T, U, V> fma(const T x, const U y, const V z) noexcept {
    using common = ywlib::cmath::common<T, U, V>;
    if constexpr (yw::same_as<common, T, U, V>) {
      if (!yw::is_cev) {
        if constexpr (yw::same_as<common, float>) return __ywlib_global fmaf(x, y, z);
        else if constexpr (yw::same_as<common, double>) return __ywlib_global fma(x, y, z);
        else return __ywlib_global fmal(x, y, z);
      } else return x * y + z;
    } else return std::fma(static_cast<common>(x), static_cast<common>(y), static_cast<common>(z));
  }
  constexpr float fmaf(float x, float y, float z) noexcept { return std::fma(x, y, z); }
  constexpr long double fmal(long double x, long double y, long double z) noexcept { return std::fma(x, y, z); }

  template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V> constexpr ywlib::cmath::common<T, U, V> lerp(T a, U b, V t) noexcept {
    using common = ywlib::cmath::common<T, U, V>;
    if constexpr (yw::same_as<common, T, U, V>) return std::fma(t, b - a, a);
    else return std::lerp(static_cast<common>(a), static_cast<common>(b), static_cast<common>(t));
  }
}
#endif

#if not __ywlib_is_imported
#define __ywlib_cmath_a1(fn, rt, rtf, rtl)                                          \
  extern "C" {                                                                      \
  __ywlib_begin;                                                                    \
  rt __cdecl fn(double);                                                            \
  rtf __cdecl fn##f(float);                                                         \
  rtl __cdecl fn##l(long double);                                                   \
  __ywlib_end;                                                                      \
  }                                                                                 \
  __ywlib_export namespace std {                                                    \
    template<yw::arithmetic T> auto fn(const T x) noexcept {                        \
      using common = ywlib::cmath::common<T>;                                       \
      if constexpr (yw::same_as<common, T>) {                                       \
        if constexpr (yw::same_as<common, float>) return __ywlib_global fn##f(x);    \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global fn(x); \
        else return __ywlib_global fn##l(x);                                         \
      } else return std::fn(static_cast<common>(x));                                \
    }                                                                               \
    inline auto fn##f(float x) noexcept { return std::fn(x); }                      \
    inline auto fn##l(long double x) noexcept { return std::fn(x); }                \
  }
#else
#define __ywlib_cmath_a1(...)
#endif

__ywlib_cmath_a1(nearbyint, double, float, long double);
__ywlib_cmath_a1(rint, double, float, long double) __ywlib_cmath_a1(lrint, long, long, long);
__ywlib_cmath_a1(llrint, long long, long long, long long) __ywlib_cmath_a1(sin, double, float, long double);
__ywlib_cmath_a1(cos, double, float, long double) __ywlib_cmath_a1(tan, double, float, long double);
__ywlib_cmath_a1(asin, double, float, long double) __ywlib_cmath_a1(acos, double, float, long double);
__ywlib_cmath_a1(atan, double, float, long double) __ywlib_cmath_a1(sinh, double, float, long double);
__ywlib_cmath_a1(cosh, double, float, long double) __ywlib_cmath_a1(tanh, double, float, long double);
__ywlib_cmath_a1(asinh, double, float, long double) __ywlib_cmath_a1(acosh, double, float, long double);
__ywlib_cmath_a1(atanh, double, float, long double) __ywlib_cmath_a1(exp, double, float, long double);
__ywlib_cmath_a1(exp2, double, float, long double) __ywlib_cmath_a1(expm1, double, float, long double);
__ywlib_cmath_a1(log, double, float, long double) __ywlib_cmath_a1(log2, double, float, long double);
__ywlib_cmath_a1(log10, double, float, long double) __ywlib_cmath_a1(log1p, double, float, long double);
__ywlib_cmath_a1(logb, double, float, long double) __ywlib_cmath_a1(ilogb, int, int, int);
__ywlib_cmath_a1(sqrt, double, float, long double) __ywlib_cmath_a1(cbrt, double, float, long double);
__ywlib_cmath_a1(erf, double, float, long double) __ywlib_cmath_a1(erfc, double, float, long double);
__ywlib_cmath_a1(lgamma, double, float, long double) __ywlib_cmath_a1(tgamma, double, float, long double)

#if not __ywlib_is_imported
#define __ywlib_cmath_a2(fn, rt, rtf, rtl)                                                          \
  extern "C" {                                                                                      \
  __ywlib_begin;                                                                                    \
  rt __cdecl fn(double, double);                                                                    \
  rtf __cdecl fn##f(float, float);                                                                  \
  rtl __cdecl fn##l(long double, long double);                                                      \
  __ywlib_end;                                                                                      \
  }                                                                                                 \
  __ywlib_export namespace std {                                                                    \
    template<yw::arithmetic T, yw::arithmetic U> constexpr auto fn(const T x, const U y) noexcept { \
      using common = ywlib::cmath::common<T, U>;                                                    \
      if constexpr (yw::same_as<common, T, U>) {                                                    \
        if constexpr (yw::same_as<common, float>) return __ywlib_global fn##f(x, y);                 \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global fn(x, y);              \
        else return __ywlib_global fn##l(x, y);                                                      \
      } else return std::fn(static_cast<common>(x), static_cast<common>(y));                        \
    }                                                                                               \
    inline auto fn##f(float x, float y) noexcept { return std::fn(x, y); }                          \
    inline auto fn##l(long double x, long double y) noexcept { return std::fn(x, y); }              \
  }
#else
#define __ywlib_cmath_a2(...)
#endif

  __ywlib_cmath_a2(atan2, double, float, long double);
__ywlib_cmath_a2(pow, double, float, long double);
__ywlib_cmath_a2(hypot, double, float, long double);
__ywlib_cmath_a2(nextafter, double, float, long double);

extern "C" {
__ywlib_begin;
double __cdecl remquo(double, double, int*);
float __cdecl remquof(float, float, int*);
long double __cdecl remquol(long double, long double, int*);
double __cdecl frexp(double, int*);
float __cdecl frexpf(float, int*);
long double __cdecl frexpl(long double, int*);
double __cdecl ldexp(double, int);
float __cdecl ldexpf(float, int);
long double __cdecl ldexpl(long double, int);
double __cdecl scalbn(double, int);
float __cdecl scalbnf(float, int);
long double __cdecl scalbnl(long double, int);
double __cdecl scalbln(double, long);
float __cdecl scalblnf(float, long);
long double __cdecl scalblnl(long double, long);
double __cdecl nexttoward(double, long double);
float __cdecl nexttowardf(float, long double);
long double __cdecl nexttowardl(long double, long double);
__ywlib_end;
}
#if not __ywlib_is_imported
__ywlib_export namespace std {
  template<yw::arithmetic T, yw::arithmetic U> constexpr ywlib::cmath::common<T, U> remquo(T x, U y, int* quo) noexcept {
    using common = ywlib::cmath::common<T, U>;
    if constexpr (yw::same_as<common, T, U>) {
      if (!yw::is_cev) {
        if constexpr (yw::same_as<common, float>) return __ywlib_global remquof(x, y, quo);
        else if constexpr (yw::same_as<common, double>) return __ywlib_global remquo(x, y, quo);
        else return __ywlib_global remquol(x, y, quo);
      } else {
        *quo = static_cast<int>(std::lround(x / y));
        if (std::fabs(*quo - x / y) == common(0.5) && *quo % 2 != 0) *quo += ((*quo > 0) ? -1 : 1);
        return static_cast<common>(x - *quo * y);
      }
    } else return std::remquo(static_cast<common>(x), static_cast<common>(y), quo);
  }
  constexpr float remquof(float x, float y, int* quo) noexcept { return std::remquo(x, y, quo); }
  constexpr long double remquol(long double x, long double y, int* quo) noexcept { return std::remquo(x, y, quo); }

  template<yw::arithmetic T> auto frexp(const T x, int* exp) noexcept {
    using common = ywlib::cmath::common<T>;
    if constexpr (yw::same_as<common, T>) {
      if constexpr (yw::same_as<common, float>) return __ywlib_global frexpf(x, exp);
      else if constexpr (yw::same_as<common, double>) return __ywlib_global frexp(x, exp);
      else return __ywlib_global frexpl(x, exp);
    } else return std::frexp(static_cast<common>(x), exp);
  }
  float frexpf(float x, int* exp) noexcept { return std::frexp(x, exp); }
  long double frexpl(long double x, int* exp) noexcept { return std::frexp(x, exp); }

  template<yw::arithmetic T> auto ldexp(const T x, const int exp) noexcept {
    using common = ywlib::cmath::common<T>;
    if constexpr (yw::same_as<common, T>) {
      if constexpr (yw::same_as<common, float>) return __ywlib_global ldexpf(x, exp);
      else if constexpr (yw::same_as<common, double>) return __ywlib_global ldexp(x, exp);
      else return __ywlib_global ldexpl(x, exp);
    } else return std::ldexp(static_cast<common>(x), exp);
  }
  float ldexpf(float x, int exp) noexcept { return std::ldexp(x, exp); }
  long double ldexpl(long double x, int exp) noexcept { return std::ldexp(x, exp); }

  template<yw::arithmetic T> auto scalbn(const T x, const int n) noexcept {
    using common = ywlib::cmath::common<T>;
    if constexpr (yw::same_as<common, T>) {
      if constexpr (yw::same_as<common, float>) return __ywlib_global scalbnf(x, n);
      else if constexpr (yw::same_as<common, double>) return __ywlib_global scalbn(x, n);
      else return __ywlib_global scalbnl(x, n);
    } else return std::scalbn(static_cast<common>(x), n);
  }
  float scalbnf(float x, int n) noexcept { return std::scalbn(x, n); }
  long double scalbnl(long double x, int n) noexcept { return std::scalbn(x, n); }

  template<yw::arithmetic T> auto scalbln(const T x, const long n) noexcept {
    using common = ywlib::cmath::common<T>;
    if constexpr (yw::same_as<common, T>) {
      if constexpr (yw::same_as<common, float>) return __ywlib_global scalblnf(x, n);
      else if constexpr (yw::same_as<common, double>) return __ywlib_global scalbln(x, n);
      else return __ywlib_global scalblnl(x, n);
    } else return std::scalbln(static_cast<common>(x), n);
  }
  float scalblnf(float x, long n) noexcept { return std::scalbln(x, n); }
  long double scalblnl(long double x, long n) noexcept { return std::scalbln(x, n); }

  template<yw::arithmetic T> auto nexttoward(const T x, long double y) noexcept {
    using common = ywlib::cmath::common<T>;
    if constexpr (yw::same_as<common, T>) {
      if constexpr (yw::same_as<common, float>) return __ywlib_global nexttowardf(x, y);
      else if constexpr (yw::same_as<common, double>) return __ywlib_global nexttoward(x, y);
      else return __ywlib_global nexttowardl(x, y);
    } else return std::nexttoward(static_cast<common>(x), static_cast<common>(y));
  }
  float nexttowardf(float x, long double y) noexcept { return std::nexttoward(x, y); }
  long double nexttowardl(long double x, long double y) noexcept { return std::nexttoward(x, y); }
}
#endif

#pragma region SPECIAL FUNCTIONS

#if not __ywlib_is_imported
#define __ywlib_cmath_s1(fn)                                                                    \
  extern "C" {                                                                                  \
  __ywlib_begin;                                                                                \
  double __cdecl __std_smf_##fn(double);                                                        \
  float __cdecl __std_smf_##fn##f(float);                                                       \
  __ywlib_end;                                                                                  \
  }                                                                                             \
  __ywlib_export namespace std {                                                                \
    template<yw::arithmetic T> auto fn(const T x) noexcept {                                    \
      using common = ywlib::cmath::common<T>;                                                   \
      if constexpr (yw::same_as<common, T>) {                                                   \
        if constexpr (yw::same_as<common, float>) return __ywlib_global __std_smf_##fn##f(x);    \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global __std_smf_##fn(x); \
        else return static_cast<common>(__ywlib_global __std_smf_##fn(static_cast<double>(x)));  \
      } else return std::fn(static_cast<common>(x));                                            \
    }                                                                                           \
  }
#else
#define __ywlib_cmath_s1(...)
#endif
__ywlib_cmath_s1(comp_ellint_1);
__ywlib_cmath_s1(comp_ellint_2);
__ywlib_cmath_s1(expint);
__ywlib_cmath_s1(riemann_zeta);

#if not __ywlib_is_imported
#define __ywlib_cmath_s2(fn)                                                                                           \
  extern "C" {                                                                                                         \
  __ywlib_begin;                                                                                                       \
  double __cdecl __std_smf_##fn(double, double);                                                                       \
  float __cdecl __std_smf_##fn##f(float, float);                                                                       \
  __ywlib_end;                                                                                                         \
  }                                                                                                                    \
  __ywlib_export namespace std {                                                                                       \
    template<yw::arithmetic T, yw::arithmetic U> auto fn(const T x, const U y) noexcept {                              \
      using common = ywlib::cmath::common<T, U>;                                                                       \
      if constexpr (yw::same_as<common, T, U>) {                                                                       \
        if constexpr (yw::same_as<common, float>) return __ywlib_global __std_smf_##fn##f(x, y);                        \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global __std_smf_##fn(x, y);                     \
        else return static_cast<common>(__ywlib_global __std_smf_##fn(static_cast<double>(x), static_cast<double>(y))); \
      } else return std::fn(static_cast<common>(x), static_cast<common>(y));                                           \
    }                                                                                                                  \
  }
#else
#define __ywlib_cmath_s2(...)
#endif
__ywlib_cmath_s2(beta);
__ywlib_cmath_s2(comp_ellint_3);
__ywlib_cmath_s2(cyl_bessel_i);
__ywlib_cmath_s2(cyl_bessel_j);
__ywlib_cmath_s2(cyl_bessel_k);
__ywlib_cmath_s2(cyl_neumann);
__ywlib_cmath_s2(ellint_1);
__ywlib_cmath_s2(ellint_2);

#if not __ywlib_is_imported
#define __ywlib_cmath_s3(fn)                                                                                                                   \
  extern "C" {                                                                                                                                 \
  __ywlib_begin;                                                                                                                               \
  double __cdecl __std_smf_##fn(double, double, double);                                                                                       \
  float __cdecl __std_smf_##fn##f(float, float, float);                                                                                        \
  __ywlib_end;                                                                                                                                 \
  }                                                                                                                                            \
  __ywlib_export namespace std {                                                                                                               \
    template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V> auto fn(const T x, const U y, const V z) noexcept {                         \
      using common = ywlib::cmath::common<T, U, V>;                                                                                            \
      if constexpr (yw::same_as<common, T, U, V>) {                                                                                            \
        if constexpr (yw::same_as<common, float>) return __ywlib_global __std_smf_##fn##f(x, y, z);                                             \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global __std_smf_##fn(x, y, z);                                          \
        else return static_cast<common>(__ywlib_global __std_smf_##fn(static_cast<double>(x), static_cast<double>(y), static_cast<double>(z))); \
      } else return std::fn(static_cast<common>(x), static_cast<common>(y), static_cast<common>(z));                                           \
    }                                                                                                                                          \
  }
#else
#define __ywlib_cmath_s3(...)
#endif
__ywlib_cmath_s3(ellint_3);
__ywlib_cmath_s3(hypot3);

#if not __ywlib_is_imported
#define __ywlib_cmath_us1(fn)                                                                      \
  extern "C" {                                                                                     \
  __ywlib_begin;                                                                                   \
  double __cdecl __std_smf_##fn(unsigned, double);                                                 \
  float __cdecl __std_smf_##fn##f(unsigned, float);                                                \
  __ywlib_end;                                                                                     \
  }                                                                                                \
  __ywlib_export namespace std {                                                                   \
    template<yw::arithmetic T> auto fn(const unsigned n, const T x) noexcept {                     \
      using common = ywlib::cmath::common<T>;                                                      \
      if constexpr (yw::same_as<common, T>) {                                                      \
        if constexpr (yw::same_as<common, float>) return __ywlib_global __std_smf_##fn##f(n, x);    \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global __std_smf_##fn(n, x); \
        else return static_cast<common>(__ywlib_global __std_smf_##fn(n, static_cast<double>(x)));  \
      } else return std::fn(n, static_cast<common>(x));                                            \
    }                                                                                              \
  }
#else
#define __ywlib_cmath_us1(...)
#endif
__ywlib_cmath_us1(hermite);
__ywlib_cmath_us1(laguerre);
__ywlib_cmath_us1(legendre);
__ywlib_cmath_us1(sph_bessel);
__ywlib_cmath_us1(sph_neumann);

#if not __ywlib_is_imported
#define __ywlib_cmath_uus1(fn)                                                                        \
  extern "C" {                                                                                        \
  __ywlib_begin;                                                                                      \
  double __cdecl __std_smf_##fn(unsigned, unsigned, double);                                          \
  float __cdecl __std_smf_##fn##f(unsigned, unsigned, float);                                         \
  __ywlib_end;                                                                                        \
  }                                                                                                   \
  __ywlib_export namespace std {                                                                      \
    template<yw::arithmetic T> auto fn(const unsigned n, const unsigned m, const T x) noexcept {      \
      using common = ywlib::cmath::common<T>;                                                         \
      if constexpr (yw::same_as<common, T>) {                                                         \
        if constexpr (yw::same_as<common, float>) return __ywlib_global __std_smf_##fn##f(n, m, x);    \
        else if constexpr (yw::same_as<common, double>) return __ywlib_global __std_smf_##fn(n, m, x); \
        else return static_cast<common>(__ywlib_global __std_smf_##fn(n, m, static_cast<double>(x)));  \
      } else return std::fn(n, m, static_cast<common>(x));                                            \
    }                                                                                                 \
  }
#else
#define __ywlib_cmath_uus1(...)
#endif
__ywlib_cmath_uus1(assoc_laguerre);
__ywlib_cmath_uus1(assoc_legendre);
__ywlib_cmath_uus1(sph_legendre);

#pragma endregion

extern "C" {
__ywlib_begin;
inline float __cdecl frexpf(float x, int* exp) { return static_cast<float>(frexp(static_cast<double>(x), exp)); }
__ywlib_end;
}
