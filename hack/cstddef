#pragma once
#include "abc.h"
namespace ywstd::cstddef {
template<typename T> struct remove_cv_ { using type = T; };
template<typename T> struct remove_cv_<const T> { using type = T; };
template<typename T> struct remove_cv_<volatile T> { using type = T; };
template<typename T> struct remove_cv_<const volatile T> { using type = T; };
template<typename T> using remove_cv = typename remove_cv_<T>::type;
template<typename T, typename U> constexpr bool same_as = false;
template<typename T> constexpr bool same_as<T, T> = true;
template<typename T, typename... Ts> concept included_in = (same_as<T, Ts> || ...);
template<typename T> concept integral = included_in<
  remove_cv<T>, bool, char, wchar_t, char8_t, char16_t, char32_t,
  signed char, short, int, long, long long,
  unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
}
__ywstd_export namespace std {
using ptrdiff_t = long long;
using size_t = unsigned long long;
using max_align_t = double;
using nullptr_t = decltype(nullptr);
enum class byte : unsigned char {};
template<ywstd::cstddef::integral T> constexpr byte operator<<(byte b, T shift) noexcept { return byte(static_cast<unsigned char>(b) << shift); }
template<ywstd::cstddef::integral T> constexpr byte operator>>(byte b, T shift) noexcept { return byte(static_cast<unsigned char>(b) >> shift); }
template<ywstd::cstddef::integral T> constexpr byte& operator<<=(byte& b, T shift) noexcept { return b = b << shift; }
template<ywstd::cstddef::integral T> constexpr byte& operator>>=(byte& b, T shift) noexcept { return b = b >> shift; }
constexpr byte operator|(byte a, byte b) noexcept { return byte(static_cast<unsigned char>(a) | static_cast<unsigned char>(b)); }
constexpr byte operator&(byte a, byte b) noexcept { return byte(static_cast<unsigned char>(a) & static_cast<unsigned char>(b)); }
constexpr byte operator^(byte a, byte b) noexcept { return byte(static_cast<unsigned char>(a) ^ static_cast<unsigned char>(b)); }
constexpr byte operator~(byte b) noexcept { return byte(~static_cast<unsigned char>(b)); }
constexpr byte& operator|=(byte& a, byte b) noexcept { return a = a | b; }
constexpr byte& operator&=(byte& a, byte b) noexcept { return a = a & b; }
constexpr byte& operator^=(byte& a, byte b) noexcept { return a = a ^ b; }
template<ywstd::cstddef::integral T> constexpr T to_integer(byte b) noexcept { return static_cast<T>(b); }
}
