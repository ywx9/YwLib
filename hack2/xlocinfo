#pragma once
#include "abc.h"
#include <__msvc_xlocinfo_types.hpp>
#include <clocale>
#include <cstdlib>
#include <intrin0.h>
#include <xutility>
#include <yvals.h>

__ywstd_cfunc_begin

#define _X_ALL LC_ALL
#define _X_COLLATE LC_COLLATE
#define _X_CTYPE LC_CTYPE
#define _X_MONETARY LC_MONETARY
#define _X_NUMERIC LC_NUMERIC
#define _X_TIME LC_TIME
#define _X_MAX LC_MAX
#define _X_MESSAGES 6
#define _NCAT (_X_MESSAGES + 1) // maximum + 1

#define _CATMASK(n) ((1 << (n)) >> 1)
#define _M_COLLATE _CATMASK(_X_COLLATE)
#define _M_CTYPE _CATMASK(_X_CTYPE)
#define _M_MONETARY _CATMASK(_X_MONETARY)
#define _M_NUMERIC _CATMASK(_X_NUMERIC)
#define _M_TIME _CATMASK(_X_TIME)
#define _M_MESSAGES _CATMASK(_X_MESSAGES)
#define _M_ALL (_CATMASK(_NCAT) - 1)

_Collvec __cdecl _Getcoll() noexcept;
_Ctypevec __cdecl _Getctype() noexcept;
_Cvtvec __cdecl _Getcvt() noexcept;
int __cdecl _Getdateorder() noexcept;
int __cdecl _Mbrtowc(wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*) noexcept;
int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*) noexcept;
size_t __cdecl _Strxfrm(char*, char*, const char*, const char*, const _Collvec*) noexcept;
int __cdecl _Wcrtomb(char*, wchar_t, mbstate_t*, const _Cvtvec*) noexcept;
int __cdecl _Wcscoll(const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;
size_t __cdecl _Wcsxfrm(wchar_t*, wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;
short __cdecl _Getwctype(wchar_t, const _Ctypevec*) noexcept;
const wchar_t* __cdecl _Getwctypes(const wchar_t*, const wchar_t*, short*, const _Ctypevec*) noexcept;

char* __cdecl _Getdays();
char* __cdecl _Getmonths();
void* __cdecl _Gettnames();
size_t __cdecl _Strftime(char*, size_t, const char*, const tm*, void*);
wchar_t* __cdecl _W_Getdays();
wchar_t* __cdecl _W_Getmonths();
void* __cdecl _W_Gettnames();
size_t __cdecl _Wcsftime(wchar_t*, size_t, const wchar_t*, const tm*, void*);

__ywstd_cfunc_end

extern "C" {

int __cdecl _Tolower(int, const _Ctypevec*) noexcept;
int __cdecl _Toupper(int, const _Ctypevec*) noexcept;
wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*) noexcept;
wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*) noexcept;
}

extern "C++" {
namespace std {

class _Timevec {
  void* _p;
public:
  ~_Timevec() noexcept { _CSTD free(_p); }
  explicit _Timevec(void* p = nullptr) : _p(p) {}
  _Timevec(const _Timevec& a) : _p(nullptr) { *this = a; }
  _Timevec& operator=(const _Timevec& a) {
    if (this != &a) {
      _CSTD free(_p);
      _p = a._p;
      const_cast<_Timevec&>(a)._p = nullptr;
    }
    return *this;
  }
  void* _Getptr() const { return _p; }
};

template<typename T> class _Yarn {
  void _Tidy() noexcept {
    if (_p) _CSTD free(_p);
    _p = nullptr;
  }
  T* _p;
  T _nul;
public:
  ~_Yarn() noexcept { _Tidy(); }
  _Yarn() noexcept : _p(nullptr), _nul(0) {}
  _Yarn(const _Yarn& a) noexcept : _p(nullptr), _nul(0) { *this = a; }
  _Yarn(const T* a) noexcept : _p(nullptr), _nul(0) { *this = a; }
  _Yarn& operator=(const _Yarn& a) noexcept { return *this = a._p; }
  _Yarn& operator=(const T* a) noexcept {
    if (_p != a) {
      _Tidy();
      if (a) {
        const T* p = a;
        while (*p != T{}) { ++p; }
        const auto _Count = (++p - a) * sizeof(T);
        if (_p = static_cast<T*>(_CSTD malloc(_Count)); _p) _CSTD memcpy(_p, a, _Count);
      }
    }
    return *this;
  }
  __ywstd_nodiscard bool empty() const noexcept { return _p == nullptr; }
  const T* c_str() const noexcept { return _p ? _p : &_nul; }
  __ywstd_nodiscard bool _Empty() const noexcept { return _p == nullptr; }
  const T* _C_str() const noexcept { return _p ? _p : &_nul; }
};

class _Locinfo {
  _Locinfo(const _Locinfo&) = delete;
  _Locinfo& operator=(const _Locinfo&) = delete;
  _Lockit _Lock;
  _Yarn<char> _Days;
  _Yarn<char> _Months;
  _Yarn<wchar_t> _W_Days;
  _Yarn<wchar_t> _W_Months;
  _Yarn<char> _Oldlocname;
  _Yarn<char> _Newlocname;
public:
  using _Collvec = ::_Collvec;
  using _Ctypevec = ::_Ctypevec;
  using _Cvtvec = ::_Cvtvec;
  using _Timevec = std::_Timevec;
  static void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
  static void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
  static void __cdecl _Locinfo_dtor(_Locinfo*);
  static _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

  ~_Locinfo() noexcept { _Locinfo_dtor(this); }
  _Locinfo(const char* _Pch = "C") : _Lock(_LOCK_LOCALE) {
    if (_Pch) {
      _Locinfo_ctor(this, _Pch);
      return;
    }
    _Xruntime_error("bad locale name");
  }
  _Locinfo(int _Cat, const char* _Pch) : _Lock(_LOCK_LOCALE) {
    if (_Pch) {
      _Locinfo_ctor(this, _Cat, _Pch);
      return;
    }
    _Xruntime_error("bad locale name");
  }
  _Locinfo& _Addcats(int _Cat, const char* _Pch) {
    if (_Pch) { return _Locinfo_Addcats(this, _Cat, _Pch); }
    _Xruntime_error("bad locale name");
  }
  const char* _Getname() const { return _Newlocname._C_str(); }
  _Collvec _Getcoll() const { return _CSTD _Getcoll(); }
  _Ctypevec _Getctype() const { return _CSTD _Getctype(); }
  _Cvtvec _Getcvt() const { return _CSTD _Getcvt(); }
  const lconv* _Getlconv() const { return _CSTD localeconv(); }
  _Timevec _Gettnames() const { return _Timevec(_CSTD _Gettnames()); }

  const char* _Getdays() const {
    if (const char* p = _CSTD _Getdays(); p) {
      const_cast<_Locinfo*>(this)->_Days = p;
      _CSTD free(const_cast<char*>(p));
    }
    return !_Days._Empty() ? _Days._C_str()
                            : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                              ":Thu:Thursday:Fri:Friday:Sat:Saturday";
  }

  const char* _Getmonths() const {
    if (const char* p = _CSTD _Getmonths(); p) {
      const_cast<_Locinfo*>(this)->_Months = p;
      _CSTD free(const_cast<char*>(p));
    }
    return !_Months._Empty() ? _Months._C_str()
                              : ":Jan:January:Feb:February:Mar:March"
                                ":Apr:April:May:May:Jun:June"
                                ":Jul:July:Aug:August:Sep:September"
                                ":Oct:October:Nov:November:Dec:December";
  }

  const char* _Getfalse() const { return "false"; }
  const char* _Gettrue() const { return "true"; }
  int _Getdateorder() const { return _CSTD _Getdateorder(); }
  _Timevec _W_Gettnames() const { return _Timevec(_CSTD _W_Gettnames()); }

  const unsigned short* _W_Getdays() const {
    if (const wchar_t* p = _CSTD _W_Getdays(); p) {
      const_cast<_Locinfo*>(this)->_W_Days = p;
      _CSTD free(const_cast<wchar_t*>(p));
    }
    const wchar_t* _Ret = _W_Days._Empty()
                            ? L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"
                            : _W_Days._C_str();
    return reinterpret_cast<const unsigned short*>(_Ret);
  }

  const unsigned short* _W_Getmonths() const {
    if (const wchar_t* p = _CSTD _W_Getmonths(); p) {
      const_cast<_Locinfo*>(this)->_W_Months = p;
      _CSTD free(const_cast<wchar_t*>(p));
    }
    const wchar_t* _Ret;
    if (_W_Months._Empty()) {
      _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
              L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
    } else _Ret = _W_Months._C_str();
    return reinterpret_cast<const unsigned short*>(_Ret);
  }
};

template<typename T> int __cdecl _LStrcoll( //
  const T* i1, const T* s1, const T* i2, const T* s2, const _Locinfo::_Collvec*) {
  for (; i1 != s1 && i2 != s2; ++i1, ++i2) {
    if (*i1 < *i2) return -1;
    else if (*i2 < *i1) return +1;
  }
  return i2 != s2 ? -1 : i1 != s1 ? +1 : 0;
}

template<> inline int __cdecl _LStrcoll( //
  const char* i1, const char* s1, const char* i2, const char* s2, const _Locinfo::_Collvec* Vec) {
  return _CSTD _Strcoll(i1, s1, i2, s2, Vec);
}

template<> inline int __cdecl _LStrcoll( //
  const wchar_t* i1, const wchar_t* s1, const wchar_t* i2, const wchar_t* s2, const _Locinfo::_Collvec* Vec) {
  return _CSTD _Wcscoll(i1, s1, i2, s2, Vec);
}

template<class T> size_t __cdecl _LStrxfrm(T* i1, T* s1, const T* i2, const T* s2, const _Locinfo::_Collvec*) {
  const ptrdiff_t _Count = s2 - i2;
  if (_Count <= s1 - i1) _CSTD memcpy(i1, i2, _Count * sizeof(T));
  return _Count;
}

template<> inline size_t __cdecl _LStrxfrm( //
  char* i1, char* s1, const char* i2, const char* s2, const _Locinfo::_Collvec* Vec) {
  return _CSTD _Strxfrm(i1, s1, i2, s2, Vec);
}

template<> inline size_t __cdecl _LStrxfrm( //
  wchar_t* i1, wchar_t* s1, const wchar_t* i2, const wchar_t* s2, const _Locinfo::_Collvec* Vec) {
  return _CSTD _Wcsxfrm(i1, s1, i2, s2, Vec);
}
}
}
