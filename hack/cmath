#pragma once // clang-format off
#include "abc.h"

#define MATH_ERRNO        1
#define MATH_ERREXCEPT    2
#define math_errhandling  (MATH_ERRNO | MATH_ERREXCEPT)

#define FP_INFINITE  1
#define FP_NAN       2
#define FP_NORMAL    (-1)
#define FP_SUBNORMAL (-2)
#define FP_ZERO      0

#define INFINITY (static_cast<float>(1e300 * 1e300))
#define NAN (-static_cast<float>(INFINITY * 0.0f))
#define HUGE_VAL (static_cast<double>(INFINITY))
#define HUGE_VALF (static_cast<float>(INFINITY))
#define HUGE_VALL (static_cast<long double>(INFINITY))

__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq

using float_t = float;
using double_t = double;

short __cdecl _dtest(double*);
short __cdecl _fdtest(float*);
short __cdecl _ldtest(long double*);

int __cdecl _dsign(double);
int __cdecl _fdsign(float);
int __cdecl _ldsign(long double);

int __cdecl _dpcomp(double, double);
int __cdecl _fdpcomp(float, float);
int __cdecl _ldpcomp(long double, long double);

double __cdecl nan(char const*);
float __cdecl nanf(char const*);
long double __cdecl nanl(char const*);

__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod

namespace ywstd::cmath {
template<typename... Ts> using common = decltype((yw::select_type<yw::integral<Ts>, double, Ts>{} + ...));
template<typename T> constexpr int fpcomp(T x, T y) noexcept {
  if (!yw::is_cev) {
    if constexpr (yw::same_as<T, float>) return __ywstd_cfunc _fdpcomp(x, y);
    else if constexpr (yw::same_as<T, double>) return __ywstd_cfunc _dpcomp(x, y);
    else if constexpr (yw::same_as<T, long double>) return __ywstd_cfunc _ldpcomp(x, y);
  } else return (x < y ? 1 : 0) | (x == y ? 2 : 0) | (x > y ? 4 : 0);
}
}

#if not __ywstd_is_imported
__ywstd_export namespace std {

using __ywstd_cfunc float_t;
using __ywstd_cfunc double_t;

template<typename T, typename U> using _Common_float_type_t = ywstd::cmath::common<float, T, U>;
template<yw::arithmetic T> constexpr int fpclassify(T x) noexcept {
  if constexpr (yw::float_type<T>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<T, float>) return __ywstd_cfunc _fdtest(&x);
      else if constexpr (yw::same_as<T, double>) return __ywstd_cfunc _dtest(&x);
      else if constexpr (yw::same_as<T, long double>) return __ywstd_cfunc _ldtest(&x);
    } else {
      using ut = yw::select_type<sizeof(T) == 4, unsigned, unsigned long long>;
      constexpr ut exp_mask = static_cast<ut>(sizeof(ut) == 4 ? 0x7F800000 : 0x7FF0000000000000);
      if (x == T(0)) return FP_ZERO;
      else if (const ut u = __builtin_bit_cast(ut, x); ((u & exp_mask) | exp_mask) == 0) return FP_SUBNORMAL;
      else if ((u & exp_mask) == exp_mask) return (u & ~exp_mask) == 0 ? FP_INFINITE : FP_NAN;
      else return FP_NORMAL;
    }
  } else return std::fpclassify(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isfinite(const T x) noexcept {
  if constexpr (yw::float_type<T>) {
    const auto fp = fpclassify(x);
    return fp != FP_INFINITE && fp != FP_NAN;
  } else return std::isfinite(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isinf(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_INFINITE;
  else return std::isinf(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isnan(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_NAN;
  else return std::isnan(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool isnormal(const T x) noexcept {
  if constexpr (yw::float_type<T>) return fpclassify(x) == FP_NORMAL;
  else return std::isnormal(static_cast<double>(x));
}
template<yw::arithmetic T> constexpr bool signbit(const T x) noexcept {
  if constexpr (yw::float_type<T>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<T, float>) return __ywstd_cfunc _fdsign(x);
      else if constexpr (yw::same_as<T, double>) return __ywstd_cfunc _dsign(x);
      else if constexpr (yw::same_as<T, long double>) return __ywstd_cfunc _ldsign(x);
    } else return x < T(0);
  } else if constexpr (yw::signed_integral<T>) return x < T(0);
  else return false;
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool isgreater(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) & 4;
  else return std::isgreater(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool isgreaterequal(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) & 6;
  else return std::isgreaterequal(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool isless(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) & 1;
  else return std::isless(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool islessequal(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) & 3;
  else return std::islessequal(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool islessgreater(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) & 5;
  else return std::islessgreater(static_cast<double>(x), static_cast<double>(y));
}
template<yw::arithmetic T, yw::arithmetic U>
constexpr bool isunordered(const T x, const U y) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) return ywstd::cmath::fpcomp(x, y) == 0;
  else return std::isunordered(static_cast<double>(x), static_cast<double>(y));
}
inline float nanf(const char* tag) { return __ywstd_cfunc nanf(tag); }
inline double nan(const char* tag) { return __ywstd_cfunc nan(tag); }
inline long double nanl(const char* tag) { return __ywstd_cfunc nanl(tag); }
}
#endif

namespace ywstd::cmath {
template<typename T> constexpr T fabs(T x) noexcept { return x < 0 ? -x : x; }
template<typename T> constexpr T ceil(T x) noexcept {
  const auto i = static_cast<T>(static_cast<long long>(x));
  return i == x ? x : (x < 0 ? i : i + 1);
}
template<typename T> constexpr T floor(T x) noexcept {
  const auto i = static_cast<T>(static_cast<long long>(x));
  return i == x ? x : (x < 0 ? i - 1 : i);
}
template<typename T> constexpr T trunc(T x) noexcept {
  return static_cast<T>(static_cast<long long>(x));
}
template<typename T> constexpr T round(T x) noexcept {
  return trunc(static_cast<T>(x < 0 ? x - 0.5 : x + 0.5));
}
template<typename T> constexpr long lround(T x) noexcept {
  return static_cast<long>(round(x));
}
template<typename T> constexpr long long llround(T x) noexcept {
  return static_cast<long long>(round(x));
}
}

#if not __ywstd_is_imported
#define __ywstd_cmath_c1(fn, rt, rtf, rtl)                                                  \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq            \
rt __cdecl fn(double);                                                                      \
rtf __cdecl fn##f(float);                                                                   \
rtl __cdecl fn##l(long double);                                                             \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod            \
__ywstd_export namespace std {                                                              \
template<yw::arithmetic T> constexpr auto fn(const T x) noexcept {                \
  using common = ywstd::cmath::common<T>;                                                   \
  if constexpr (yw::same_as<common, T>) {                                         \
    if (!yw::is_cev) {                                               \
      if constexpr (yw::same_as<common, float>) return __ywstd_cfunc fn##f(x);    \
      else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc fn(x); \
      else return __ywstd_cfunc fn##l(x);                                                   \
    } else return ywstd::cmath::fn(x);                                                      \
  } else return std::fn(static_cast<common>(x));                                            \
}                                                                                           \
constexpr auto fn##f(float x) noexcept { return std::fn(x); }                               \
constexpr auto fn##l(long double x) noexcept { return std::fn(x); }                         \
}
#else
#define __ywstd_cmath_c1(...)
#endif

__ywstd_cmath_c1(fabs, double, float, long double);
__ywstd_cmath_c1(ceil, double, float, long double);
__ywstd_cmath_c1(floor, double, float, long double);
__ywstd_cmath_c1(trunc, double, float, long double);
__ywstd_cmath_c1(round, double, float, long double);
__ywstd_cmath_c1(lround, long, long, long);
__ywstd_cmath_c1(llround, long long, long long, long long);

namespace ywstd::cmath {
template<typename T> constexpr T copysign(T mag, T sgn) noexcept {
  return fabs(mag) * (sgn < 0 ? -1 : 1);
}
template<typename T> constexpr T fmod(T x, T y) noexcept {
  return x - y * static_cast<T>(static_cast<long long>(x / y));
}
template<typename T> constexpr T remainder(T x, T y) noexcept {
  auto quo = std::llround(x / y);
  if (std::fabs(quo - x / y) == T(0.5) && quo % 2 != 0) quo += (quo > 0) ? -1 : 1;
  return x - quo * y;
}
template<typename T> constexpr T fmax(T x, T y) noexcept { return x > y ? x : y; }
template<typename T> constexpr T fmin(T x, T y) noexcept { return x < y ? x : y; }
template<typename T> constexpr T fdim(T x, T y) noexcept { return fmax(x - y, T(0)); }
}

#if not __ywstd_is_imported
#define __ywstd_cmath_c2(fn, rt, rtf, rtl)                                                     \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq               \
rt __cdecl fn(double, double);                                                                 \
rtf __cdecl fn##f(float, float);                                                               \
rtl __cdecl fn##l(long double, long double);                                                   \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod               \
__ywstd_export namespace std {                                                                 \
template<yw::arithmetic T, yw::arithmetic U>                               \
constexpr auto fn(const T x, const U y) noexcept {                                             \
  using common = ywstd::cmath::common<T, U>;                                                   \
  if constexpr (yw::same_as<common, T, U>) {                                         \
    if (!yw::is_cev) {                                                  \
      if constexpr (yw::same_as<common, float>) return __ywstd_cfunc fn##f(x, y);    \
      else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc fn(x, y); \
      else return __ywstd_cfunc fn##l(x, y);                                                   \
    } else return ywstd::cmath::fn(x, y);                                                      \
  } else return std::fn(static_cast<common>(x), static_cast<common>(y));                       \
}                                                                                              \
constexpr auto fn##f(float x, float y) noexcept { return std::fn(x, y); }                      \
constexpr auto fn##l(long double x, long double y) noexcept { return std::fn(x, y); }          \
}
#else
#define __ywstd_cmath_c2(...)
#endif

__ywstd_cmath_c2(copysign, double, float, long double);
__ywstd_cmath_c2(fmod, double, float, long double);
__ywstd_cmath_c2(remainder, double, float, long double);
__ywstd_cmath_c2(fmax, double, float, long double);
__ywstd_cmath_c2(fmin, double, float, long double);
__ywstd_cmath_c2(fdim, double, float, long double);

__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq
double __cdecl fma(double, double, double);
float __cdecl fmaf(float, float, float);
long double __cdecl fmal(long double, long double, long double);
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod

#if not __ywstd_is_imported
__ywstd_export namespace std {
template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V>
constexpr ywstd::cmath::common<T, U, V> fma(const T x, const U y, const V z) noexcept {
  using common = ywstd::cmath::common<T, U, V>;
  if constexpr (yw::same_as<common, T, U, V>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<common, float>) return __ywstd_cfunc fmaf(x, y, z);
      else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc fma(x, y, z);
      else return __ywstd_cfunc fmal(x, y, z);
    } else return x * y + z;
  } else return std::fma(static_cast<common>(x), static_cast<common>(y), static_cast<common>(z));
}
constexpr float fmaf(float x, float y, float z) noexcept { return std::fma(x, y, z); }
constexpr long double fmal(long double x, long double y, long double z) noexcept { return std::fma(x, y, z); }

template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V>
constexpr ywstd::cmath::common<T, U, V> lerp(T a, U b, V t) noexcept {
  using common = ywstd::cmath::common<T, U, V>;
  if constexpr (yw::same_as<common, T, U, V>) return std::fma(t, b - a, a);
  else return std::lerp(static_cast<common>(a), static_cast<common>(b), static_cast<common>(t));
}
}
#endif

#if not __ywstd_is_imported
#define __ywstd_cmath_a1(fn, rt, rtf, rtl)                                                \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq          \
rt __cdecl fn(double);                                                                    \
rtf __cdecl fn##f(float);                                                                 \
rtl __cdecl fn##l(long double);                                                           \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod          \
__ywstd_export namespace std {                                                            \
template<yw::arithmetic T> auto fn(const T x) noexcept {                        \
  using common = ywstd::cmath::common<T>;                                                 \
  if constexpr (yw::same_as<common, T>) {                                       \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc fn##f(x);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc fn(x); \
    else return __ywstd_cfunc fn##l(x);                                                   \
  } else return std::fn(static_cast<common>(x));                                          \
}                                                                                         \
inline auto fn##f(float x) noexcept { return std::fn(x); }                                \
inline auto fn##l(long double x) noexcept { return std::fn(x); }                          \
}
#else
#define __ywstd_cmath_a1(...)
#endif

__ywstd_cmath_a1(nearbyint, double, float, long double);
__ywstd_cmath_a1(rint, double, float, long double)
__ywstd_cmath_a1(lrint, long, long, long);
__ywstd_cmath_a1(llrint, long long, long long, long long)
__ywstd_cmath_a1(sin, double, float, long double);
__ywstd_cmath_a1(cos, double, float, long double)
__ywstd_cmath_a1(tan, double, float, long double);
__ywstd_cmath_a1(asin, double, float, long double)
__ywstd_cmath_a1(acos, double, float, long double);
__ywstd_cmath_a1(atan, double, float, long double)
__ywstd_cmath_a1(sinh, double, float, long double);
__ywstd_cmath_a1(cosh, double, float, long double)
__ywstd_cmath_a1(tanh, double, float, long double);
__ywstd_cmath_a1(asinh, double, float, long double)
__ywstd_cmath_a1(acosh, double, float, long double);
__ywstd_cmath_a1(atanh, double, float, long double)
__ywstd_cmath_a1(exp, double, float, long double);
__ywstd_cmath_a1(exp2, double, float, long double)
__ywstd_cmath_a1(expm1, double, float, long double);
__ywstd_cmath_a1(log, double, float, long double)
__ywstd_cmath_a1(log2, double, float, long double);
__ywstd_cmath_a1(log10, double, float, long double)
__ywstd_cmath_a1(log1p, double, float, long double);
__ywstd_cmath_a1(logb, double, float, long double)
__ywstd_cmath_a1(ilogb, int, int, int);
__ywstd_cmath_a1(sqrt, double, float, long double)
__ywstd_cmath_a1(cbrt, double, float, long double);
__ywstd_cmath_a1(erf, double, float, long double)
__ywstd_cmath_a1(erfc, double, float, long double);
__ywstd_cmath_a1(lgamma, double, float, long double)
__ywstd_cmath_a1(tgamma, double, float, long double)

#if not __ywstd_is_imported
#define __ywstd_cmath_a2(fn, rt, rtf, rtl)                                                   \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq             \
rt __cdecl fn(double, double);                                                               \
rtf __cdecl fn##f(float, float);                                                             \
rtl __cdecl fn##l(long double, long double);                                                 \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod             \
__ywstd_export namespace std {                                                               \
template<yw::arithmetic T, yw::arithmetic U>                             \
constexpr auto fn(const T x, const U y) noexcept {                                           \
  using common = ywstd::cmath::common<T, U>;                                                 \
  if constexpr (yw::same_as<common, T, U>) {                                       \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc fn##f(x, y);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc fn(x, y); \
    else return __ywstd_cfunc fn##l(x, y);                                                   \
  } else return std::fn(static_cast<common>(x), static_cast<common>(y));                     \
}                                                                                            \
inline auto fn##f(float x, float y) noexcept { return std::fn(x, y); }                       \
inline auto fn##l(long double x, long double y) noexcept { return std::fn(x, y); }           \
}
#else
#define __ywstd_cmath_a2(...)
#endif

__ywstd_cmath_a2(atan2, double, float, long double);
__ywstd_cmath_a2(pow, double, float, long double);
__ywstd_cmath_a2(hypot, double, float, long double);
__ywstd_cmath_a2(nextafter, double, float, long double);

__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq
double __cdecl remquo(double, double, int*);
float __cdecl remquof(float, float, int*);
long double __cdecl remquol(long double, long double, int*);
double __cdecl frexp(double, int*);
float __cdecl frexpf(float, int*);
long double __cdecl frexpl(long double, int*);
double __cdecl ldexp(double, int);
float __cdecl ldexpf(float, int);
long double __cdecl ldexpl(long double, int);
double __cdecl scalbn(double, int);
float __cdecl scalbnf(float, int);
long double __cdecl scalbnl(long double, int);
double __cdecl scalbln(double, long);
float __cdecl scalblnf(float, long);
long double __cdecl scalblnl(long double, long);
double __cdecl nexttoward(double, long double);
float __cdecl nexttowardf(float, long double);
long double __cdecl nexttowardl(long double, long double);
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod

#if not __ywstd_is_imported
__ywstd_export namespace std {
template<yw::arithmetic T, yw::arithmetic U>
constexpr ywstd::cmath::common<T, U> remquo(T x, U y, int* quo) noexcept {
  using common = ywstd::cmath::common<T, U>;
  if constexpr (yw::same_as<common, T, U>) {
    if (!yw::is_cev) {
      if constexpr (yw::same_as<common, float>) return __ywstd_cfunc remquof(x, y, quo);
      else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc remquo(x, y, quo);
      else return __ywstd_cfunc remquol(x, y, quo);
    } else {
      *quo = static_cast<int>(std::lround(x / y));
      if (std::fabs(*quo - x / y) == common(0.5) && *quo % 2 != 0) *quo += ((*quo > 0) ? -1 : 1);
      return static_cast<common>(x - *quo * y);
    }
  } else return std::remquo(static_cast<common>(x), static_cast<common>(y), quo);
}
constexpr float remquof(float x, float y, int* quo) noexcept { return std::remquo(x, y, quo); }
constexpr long double remquol(long double x, long double y, int* quo) noexcept { return std::remquo(x, y, quo); }

template<yw::arithmetic T> auto frexp(const T x, int* exp) noexcept {
  using common = ywstd::cmath::common<T>;
  if constexpr (yw::same_as<common, T>) {
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc frexpf(x, exp);
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc frexp(x, exp);
    else return __ywstd_cfunc frexpl(x, exp);
  } else return std::frexp(static_cast<common>(x), exp);
}
float frexpf(float x, int* exp) noexcept { return std::frexp(x, exp); }
long double frexpl(long double x, int* exp) noexcept { return std::frexp(x, exp); }

template<yw::arithmetic T> auto ldexp(const T x, const int exp) noexcept {
  using common = ywstd::cmath::common<T>;
  if constexpr (yw::same_as<common, T>) {
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc ldexpf(x, exp);
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc ldexp(x, exp);
    else return __ywstd_cfunc ldexpl(x, exp);
  } else return std::ldexp(static_cast<common>(x), exp);
}
float ldexpf(float x, int exp) noexcept { return std::ldexp(x, exp); }
long double ldexpl(long double x, int exp) noexcept { return std::ldexp(x, exp); }

template<yw::arithmetic T> auto scalbn(const T x, const int n) noexcept {
  using common = ywstd::cmath::common<T>;
  if constexpr (yw::same_as<common, T>) {
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc scalbnf(x, n);
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc scalbn(x, n);
    else return __ywstd_cfunc scalbnl(x, n);
  } else return std::scalbn(static_cast<common>(x), n);
}
float scalbnf(float x, int n) noexcept { return std::scalbn(x, n); }
long double scalbnl(long double x, int n) noexcept { return std::scalbn(x, n); }

template<yw::arithmetic T> auto scalbln(const T x, const long n) noexcept {
  using common = ywstd::cmath::common<T>;
  if constexpr (yw::same_as<common, T>) {
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc scalblnf(x, n);
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc scalbln(x, n);
    else return __ywstd_cfunc scalblnl(x, n);
  } else return std::scalbln(static_cast<common>(x), n);
}
float scalblnf(float x, long n) noexcept { return std::scalbln(x, n); }
long double scalblnl(long double x, long n) noexcept { return std::scalbln(x, n); }

template<yw::arithmetic T> auto nexttoward(const T x, long double y) noexcept {
  using common = ywstd::cmath::common<T>;
  if constexpr (yw::same_as<common, T>) {
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc nexttowardf(x, y);
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc nexttoward(x, y);
    else return __ywstd_cfunc nexttowardl(x, y);
  } else return std::nexttoward(static_cast<common>(x), static_cast<common>(y));
}
float nexttowardf(float x, long double y) noexcept { return std::nexttoward(x, y); }
long double nexttowardl(long double x, long double y) noexcept { return std::nexttoward(x, y); }
}
#endif

#pragma region SPECIAL FUNCTIONS

#if not __ywstd_is_imported
#define __ywstd_cmath_s1(fn)                                                                          \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq                      \
double __cdecl __std_smf_##fn(double);                                                                \
float __cdecl __std_smf_##fn##f(float);                                                               \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod                      \
__ywstd_export namespace std {                                                                        \
template<yw::arithmetic T> auto fn(const T x) noexcept {                                    \
  using common = ywstd::cmath::common<T>;                                                             \
  if constexpr (yw::same_as<common, T>) {                                                   \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc __std_smf_##fn##f(x);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc __std_smf_##fn(x); \
    else return static_cast<common>(__ywstd_cfunc __std_smf_##fn(static_cast<double>(x)));            \
  } else return std::fn(static_cast<common>(x)); } }
#else
#define __ywstd_cmath_s1(...)
#endif
__ywstd_cmath_s1(comp_ellint_1);
__ywstd_cmath_s1(comp_ellint_2);
__ywstd_cmath_s1(expint);
__ywstd_cmath_s1(riemann_zeta);

#if not __ywstd_is_imported
#define __ywstd_cmath_s2(fn)                                                                                       \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq                                   \
double __cdecl __std_smf_##fn(double, double);                                                                     \
float __cdecl __std_smf_##fn##f(float, float);                                                                     \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod                                   \
__ywstd_export namespace std {                                                                                     \
template<yw::arithmetic T, yw::arithmetic U>                                                   \
auto fn(const T x, const U y) noexcept {                                                                           \
  using common = ywstd::cmath::common<T, U>;                                                                       \
  if constexpr (yw::same_as<common, T, U>) {                                                             \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc __std_smf_##fn##f(x, y);              \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc __std_smf_##fn(x, y);           \
    else return static_cast<common>(__ywstd_cfunc __std_smf_##fn(static_cast<double>(x), static_cast<double>(y))); \
  } else return std::fn(static_cast<common>(x), static_cast<common>(y)); } }
#else
#define __ywstd_cmath_s2(...)
#endif
__ywstd_cmath_s2(beta);
__ywstd_cmath_s2(comp_ellint_3);
__ywstd_cmath_s2(cyl_bessel_i);
__ywstd_cmath_s2(cyl_bessel_j);
__ywstd_cmath_s2(cyl_bessel_k);
__ywstd_cmath_s2(cyl_neumann);
__ywstd_cmath_s2(ellint_1);
__ywstd_cmath_s2(ellint_2);

#if not __ywstd_is_imported
#define __ywstd_cmath_s3(fn)                                                                                \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq                            \
double __cdecl __std_smf_##fn(double, double, double);                                                      \
float __cdecl __std_smf_##fn##f(float, float, float);                                                       \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod                            \
__ywstd_export namespace std {                                                                              \
template<yw::arithmetic T, yw::arithmetic U, yw::arithmetic V>                \
auto fn(const T x, const U y, const V z) noexcept {                                                         \
  using common = ywstd::cmath::common<T, U, V>;                                                             \
  if constexpr (yw::same_as<common, T, U, V>) {                                                   \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc __std_smf_##fn##f(x, y, z);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc __std_smf_##fn(x, y, z); \
    else return static_cast<common>(__ywstd_cfunc __std_smf_##fn(                                           \
      static_cast<double>(x), static_cast<double>(y), static_cast<double>(z))); }                           \
  else return std::fn(static_cast<common>(x), static_cast<common>(y), static_cast<common>(z)); } }
#else
#define __ywstd_cmath_s3(...)
#endif
__ywstd_cmath_s3(ellint_3);
__ywstd_cmath_s3(hypot3);

#if not __ywstd_is_imported
#define __ywstd_cmath_us1(fn)                                                                            \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq                         \
double __cdecl __std_smf_##fn(unsigned, double);                                                         \
float __cdecl __std_smf_##fn##f(unsigned, float);                                                        \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod                         \
__ywstd_export namespace std {                                                                           \
template<yw::arithmetic T> auto fn(const unsigned n, const T x) noexcept {                     \
  using common = ywstd::cmath::common<T>;                                                                \
  if constexpr (yw::same_as<common, T>) {                                                      \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc __std_smf_##fn##f(n, x);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc __std_smf_##fn(n, x); \
    else return static_cast<common>(__ywstd_cfunc __std_smf_##fn(n, static_cast<double>(x)));            \
  } else return std::fn(n, static_cast<common>(x)); } }
#else
#define __ywstd_cmath_us1(...)
#endif
__ywstd_cmath_us1(hermite);
__ywstd_cmath_us1(laguerre);
__ywstd_cmath_us1(legendre);
__ywstd_cmath_us1(sph_bessel);
__ywstd_cmath_us1(sph_neumann);

#if not __ywstd_is_imported
#define __ywstd_cmath_uus1(fn)                                                                              \
__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq                            \
double __cdecl __std_smf_##fn(unsigned, unsigned, double);                                                  \
float __cdecl __std_smf_##fn##f(unsigned, unsigned, float);                                                 \
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod                            \
__ywstd_export namespace std {                                                                              \
template<yw::arithmetic T> auto fn(const unsigned n, const unsigned m, const T x) noexcept {      \
  using common = ywstd::cmath::common<T>;                                                                   \
  if constexpr (yw::same_as<common, T>) {                                                         \
    if constexpr (yw::same_as<common, float>) return __ywstd_cfunc __std_smf_##fn##f(n, m, x);    \
    else if constexpr (yw::same_as<common, double>) return __ywstd_cfunc __std_smf_##fn(n, m, x); \
    else return static_cast<common>(__ywstd_cfunc __std_smf_##fn(n, m, static_cast<double>(x)));            \
  } else return std::fn(n, m, static_cast<common>(x)); } }
#else
#define __ywstd_cmath_uus1(...)
#endif
__ywstd_cmath_uus1(assoc_laguerre);
__ywstd_cmath_uus1(assoc_legendre);
__ywstd_cmath_uus1(sph_legendre);

#pragma endregion

__ywstd_cfunc_begin_poqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoqpoq
inline float __cdecl frexpf(float x, int* exp) {
  return static_cast<float>(frexp(static_cast<double>(x), exp));
}
__ywstd_cfunc_end___bodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbodbod
